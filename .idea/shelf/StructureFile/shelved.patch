Index: src/main/java/chylex/hee/game/world/structure/file/StructureFile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.world.structure.file\nimport chylex.hee.game.block.BlockScaffolding\nimport chylex.hee.game.world.BoundingBox\nimport chylex.hee.game.world.Pos\nimport chylex.hee.game.world.Size\nimport chylex.hee.game.world.generation.WorldToStructureWorldAdapter\nimport chylex.hee.game.world.structure.IBlockPicker\nimport chylex.hee.game.world.structure.IBlockPicker.Fallback\nimport chylex.hee.game.world.structure.IBlockPicker.Single\nimport chylex.hee.game.world.structure.IStructureGenerator\nimport chylex.hee.game.world.structure.IStructureWorld\nimport chylex.hee.game.world.structure.palette.Palette\nimport chylex.hee.init.ModBlocks\nimport chylex.hee.system.migration.Blocks\nimport chylex.hee.system.serialization.NBTList.Companion.putList\nimport chylex.hee.system.serialization.NBTObjectList\nimport chylex.hee.system.serialization.TagCompound\nimport chylex.hee.system.serialization.getListOfStrings\nimport it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap\nimport it.unimi.dsi.fastutil.ints.IntArrayList\nimport net.minecraft.block.BlockState\nimport net.minecraft.util.math.BlockPos\nimport net.minecraft.world.World\n\nclass StructureFile(nbt: TagCompound){\n\tprivate val palette: Array<String>\n\tprivate val blocks = IntArrayList()\n\t\n\tval size: Size\n\t\n\tinit{\n\t\tval tagPalette = nbt.getListOfStrings(PALETTE_TAG)\n\t\tval tagBlocks = nbt.getIntArray(BLOCKS_TAG)\n\t\tval tagSize = nbt.getIntArray(SIZE_TAG)\n\t\t\n\t\tpalette = tagPalette.toList().toTypedArray()\n\t\t\n\t\tblocks.addElements(0, tagBlocks)\n\t\tblocks.trim()\n\t\t\n\t\tsize = Size(tagSize[0], tagSize[1], tagSize[2])\n\t}\n\t\n\tinner class Generator(paletteMapping: Map<String, IBlockPicker>) : IStructureGenerator{\n\t\tprivate val generators = palette.map { paletteMapping[it] ?: Fallback(\"[StructureFile] skipping unknown palette identifier: $it\", Blocks.AIR) }.toTypedArray()\n\t\t\n\t\toverride val size = this@StructureFile.size\n\t\t\n\t\toverride fun generate(world: IStructureWorld){\n\t\t\tval rand = world.rand\n\t\t\t\n\t\t\tfor(block in blocks.elements()){\n\t\t\t\tval x = (block shr 24) and 255\n\t\t\t\tval y = (block shr 16) and 255\n\t\t\t\tval z = (block shr  8) and 255\n\t\t\t\tval id = block and 255\n\t\t\t\t\n\t\t\t\tworld.setState(Pos(x, y, z), generators[id].pick(rand))\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcompanion object{\n\t\tprivate const val PALETTE_TAG = \"Palette\"\n\t\tprivate const val BLOCKS_TAG = \"Blocks\"\n\t\tprivate const val SIZE_TAG = \"Size\"\n\t\t\n\t\tprivate val SKIP_BLOCK_STATE = ModBlocks.SCAFFOLDING.defaultState\n\t\t\n\t\tfun spawn(world: World, offset: BlockPos, piece: IStructurePieceFromFile, palette: Palette){\n\t\t\treturn spawn(WorldToStructureWorldAdapter(world, world.rand, offset), piece, palette)\n\t\t}\n\t\t\n\t\tfun spawn(world: IStructureWorld, generator: IStructurePieceFromFile, palette: Palette){\n\t\t\tval path = generator.path\n\t\t\tval size = generator.size\n\t\t\t\n\t\t\tworld.placeCube(size.minPos, size.maxPos, Single(SKIP_BLOCK_STATE))\n\t\t\tworld.apply(StructureFiles.loadSkipCache(path).Generator(palette.mappingForDevelopment)::generate)\n\t\t\tworld.finalize()\n\t\t}\n\t\t\n\t\tfun save(world: World, box: BoundingBox, palette: Palette): Pair<TagCompound, Set<BlockState>>{\n\t\t\treturn save(WorldToStructureWorldAdapter(world, world.rand, box.min), box.size, palette)\n\t\t}\n\t\t\n\t\tfun save(world: IStructureWorld, size: Size, palette: Palette): Pair<TagCompound, Set<BlockState>>{\n\t\t\trequire(size.x <= 256 && size.y <= 256 && size.z <= 256){ \"structure files can only contain structures up to 256x256x256 blocks\" }\n\t\t\t\n\t\t\tval missingMappings = mutableSetOf<BlockState>()\n\t\t\t\n\t\t\tval paletteMapping = palette.lookupForDevelopment\n\t\t\tval blockMapping = Int2ObjectArrayMap<String>()\n\t\t\t\n\t\t\tfor(x in 0..size.maxX) for(y in 0..size.maxY) for(z in 0..size.maxZ){\n\t\t\t\tval pos = Pos(x, y, z)\n\t\t\t\tval state = world.getState(pos)\n\t\t\t\t\n\t\t\t\tif (state.block is BlockScaffolding){\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar mapping = paletteMapping[state]\n\t\t\t\t\n\t\t\t\tif (mapping == null){\n\t\t\t\t\tmissingMappings.add(state)\n\t\t\t\t\tmapping = paletteMapping[Blocks.AIR.defaultState] ?: continue\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tval key = (\n\t\t\t\t\t((pos.x and 255) shl 24) or\n\t\t\t\t\t((pos.y and 255) shl 16) or\n\t\t\t\t\t((pos.z and 255) shl  8)\n\t\t\t\t)\n\t\t\t\t\n\t\t\t\tblockMapping[key] = mapping // kotlin indexer boxes the values\n\t\t\t}\n\t\t\t\n\t\t\tval generatedBlocks = IntArrayList(blockMapping.size)\n\t\t\tval generatedPalette = blockMapping.values.distinct().sorted()\n\t\t\t\n\t\t\trequire(generatedPalette.size <= 256){ \"structure files can only contain up to 256 different palette mappings\" }\n\t\t\t\n\t\t\tfor((key, mapping) in blockMapping){\n\t\t\t\tgeneratedBlocks.add(key or generatedPalette.indexOf(mapping))\n\t\t\t}\n\t\t\t\n\t\t\tval nbt = TagCompound().also {\n\t\t\t\tit.putList(PALETTE_TAG, NBTObjectList.of(generatedPalette.asIterable()))\n\t\t\t\tit.putIntArray(BLOCKS_TAG, generatedBlocks.toIntArray())\n\t\t\t\tit.putIntArray(SIZE_TAG, intArrayOf(size.x, size.y, size.z))\n\t\t\t}\n\t\t\t\n\t\t\treturn nbt to missingMappings\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/world/structure/file/StructureFile.kt	(revision d5e80a858ef66da4fc267cca0a294448bd6350f5)
+++ src/main/java/chylex/hee/game/world/structure/file/StructureFile.kt	(date 1601270796256)
@@ -113,7 +113,8 @@
 					((pos.z and 255) shl  8)
 				)
 				
-				blockMapping[key] = mapping // kotlin indexer boxes the values
+				@Suppress("ReplacePutWithAssignment")
+				blockMapping.put(key, mapping) // kotlin indexer boxes the values
 			}
 			
 			val generatedBlocks = IntArrayList(blockMapping.size)
