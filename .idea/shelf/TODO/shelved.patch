Index: src/main/java/chylex/hee/game/world/territory/descriptions/Territory_ObsidianTowers.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.world.territory.descriptions\nimport chylex.hee.game.world.territory.ITerritoryDescription\nimport chylex.hee.game.world.territory.properties.TerritoryColors\nimport chylex.hee.game.world.territory.properties.TerritoryEnvironment\nimport chylex.hee.system.util.color.IntColor.Companion.RGB\nimport chylex.hee.system.util.nextFloat\nimport net.minecraft.util.math.Vec3d\nimport java.util.Random\n\nobject Territory_ObsidianTowers : ITerritoryDescription{\n\toverride val colors = object : TerritoryColors(){\n\t\toverride val tokenTop    = RGB(146, 130, 185)\n\t\toverride val tokenBottom = RGB( 81, 173, 250)\n\t\t\n\t\toverride val portalSeed = 5555L\n\t\t\n\t\toverride fun nextPortalColor(rand: Random, color: FloatArray){\n\t\t\tif (rand.nextBoolean()){\n\t\t\t\tcolor[0] = rand.nextFloat(0.2F, 0.5F)\n\t\t\t\tcolor[1] = rand.nextFloat(0.7F, 0.9F)\n\t\t\t\tcolor[2] = 1F\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcolor[0] = rand.nextFloat(0.5F, 0.7F)\n\t\t\t\tcolor[1] = 0.5F\n\t\t\t\tcolor[2] = rand.nextFloat(0.9F, 1F)\n\t\t\t}\n\t\t}\n\t}\n\t\n\toverride val environment = object : TerritoryEnvironment(){\n\t\toverride val fogColor = Vec3d(0.0, 0.0, 0.0)\n\t\toverride val fogDensity = 0.01F\n\t\toverride val fogRenderDistanceModifier = 0.005F\n\t\t\n\t\toverride val voidRadiusMpXZ = 2F\n\t\toverride val voidRadiusMpY = 2.5F\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/world/territory/descriptions/Territory_ObsidianTowers.kt	(revision d2db1adf0c9cb6849db18efe50855702922d4745)
+++ src/main/java/chylex/hee/game/world/territory/descriptions/Territory_ObsidianTowers.kt	(date 1601019055585)
@@ -1,8 +1,10 @@
 package chylex.hee.game.world.territory.descriptions
+import chylex.hee.client.render.territory.components.SkyCubeStatic
 import chylex.hee.game.world.territory.ITerritoryDescription
 import chylex.hee.game.world.territory.properties.TerritoryColors
 import chylex.hee.game.world.territory.properties.TerritoryEnvironment
 import chylex.hee.system.util.color.IntColor.Companion.RGB
+import chylex.hee.system.util.facades.Resource
 import chylex.hee.system.util.nextFloat
 import net.minecraft.util.math.Vec3d
 import java.util.Random
@@ -35,5 +37,11 @@
 		
 		override val voidRadiusMpXZ = 2F
 		override val voidRadiusMpY = 2.5F
+		
+		override val renderer = SkyCubeStatic(
+			texture = Resource.Vanilla("textures/environment/end_sky.png"),
+			color = (30.0 / 255.0).let { Vec3d(it, it, it) },
+			rescale = 12F
+		)
 	}
 }
Index: src/main/java/chylex/hee/game/entity/living/ai/path/PathNavigateGroundPreferBeeLine.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.living.ai.path\nimport chylex.hee.system.util.nextInt\nimport chylex.hee.system.util.posVec\nimport chylex.hee.system.util.square\nimport net.minecraft.entity.Entity\nimport net.minecraft.entity.MobEntity\nimport net.minecraft.pathfinding.GroundPathNavigator\nimport net.minecraft.util.math.Vec3d\nimport net.minecraft.world.World\n\nclass PathNavigateGroundPreferBeeLine(entity: MobEntity, world: World, private val maxStuckTicks: Int, private val fallbackPathfindingResetTicks: IntRange) : GroundPathNavigator(entity, world){\n\tprivate var beelineTarget = Vec3d.ZERO\n\tprivate var beelineSpeed = 0.0\n\t\n\tprivate var lastX = entity.posX\n\tprivate var lastZ = entity.posZ\n\t\n\tprivate var stuckTicks = 0\n\tprivate var stuckLongTicks = 0\n\tprivate var resetTicks = 0\n\t\n\tval isBeelining\n\t\tget() = beelineSpeed > 0.0\n\t\n\toverride fun noPath(): Boolean{\n\t\treturn super.noPath() && beelineSpeed == 0.0\n\t}\n\t\n\toverride fun tryMoveToXYZ(x: Double, y: Double, z: Double, speed: Double): Boolean{\n\t\treturn tryBeelineTo(x, y, z, speed) || super.tryMoveToXYZ(x, y, z, speed)\n\t}\n\t\n\toverride fun tryMoveToEntityLiving(target: Entity, speed: Double): Boolean{\n\t\treturn tryBeelineTo(target.posX, target.posY, target.posZ, speed) || super.tryMoveToEntityLiving(target, speed)\n\t}\n\t\n\tprivate fun tryBeelineTo(x: Double, y: Double, z: Double, speed: Double): Boolean{\n\t\tif (resetTicks > 0){\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tbeelineTarget = Vec3d(x, y, z)\n\t\tbeelineSpeed = speed\n\t\treturn true\n\t}\n\t\n\toverride fun tick(){\n\t\tif (!super.noPath()){\n\t\t\tbeelineSpeed = 0.0\n\t\t\tsuper.tick()\n\t\t\t\n\t\t\tif (resetTicks > 0 && --resetTicks == 0){\n\t\t\t\tresetStuck()\n\t\t\t\t\n\t\t\t\tif (beelineTarget != Vec3d.ZERO){\n\t\t\t\t\tbeelineSpeed = speed\n\t\t\t\t\ttimeoutTimer = 0L\n\t\t\t\t\tsuper.clearPath()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (isBeelining){\n\t\t\tdoBeelineMovement()\n\t\t}\n\t}\n\t\n\tprivate fun doBeelineMovement(){\n\t\tval targetDistSq = entity.posVec.squareDistanceTo(beelineTarget)\n\t\tval movedDistSq = square(entity.posX - lastX) + square(entity.posZ - lastZ)\n\t\t\n\t\tif (targetDistSq > square(2.5) && movedDistSq < square(0.33)){\n\t\t\tif (++stuckTicks > maxStuckTicks){\n\t\t\t\tonStuck()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\telse if (movedDistSq < square(1.33) && ++stuckLongTicks > maxStuckTicks * 3){\n\t\t\tonStuck()\n\t\t\treturn\n\t\t}\n\t\telse{\n\t\t\tresetStuck()\n\t\t}\n\t\t\n\t\tif (targetDistSq >= square(entity.width)){\n\t\t\tentity.moveHelper.setMoveTo(beelineTarget.x, beelineTarget.y, beelineTarget.z, beelineSpeed)\n\t\t}\n\t\telse{\n\t\t\tclearPath()\n\t\t}\n\t}\n\t\n\tprivate fun onStuck(){\n\t\tstuckTicks = 0\n\t\tstuckLongTicks = 0\n\t\t\n\t\tresetTicks = entity.rng.nextInt(fallbackPathfindingResetTicks)\n\t\ttimeoutTimer = 0L\n\t\t\n\t\tif (!super.tryMoveToXYZ(beelineTarget.x, beelineTarget.y, beelineTarget.z, beelineSpeed)){\n\t\t\tbeelineSpeed = 0.0\n\t\t}\n\t}\n\t\n\tprivate fun resetStuck(){\n\t\tlastX = entity.posX\n\t\tlastZ = entity.posZ\n\t\tstuckTicks = 0\n\t}\n\t\n\toverride fun clearPath(){\n\t\tsuper.clearPath()\n\t\tresetStuck()\n\t\tstuckLongTicks = 0\n\t\tresetTicks = 0\n\t\tbeelineTarget = Vec3d.ZERO\n\t\tbeelineSpeed = 0.0\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/living/ai/path/PathNavigateGroundPreferBeeLine.kt	(revision d2db1adf0c9cb6849db18efe50855702922d4745)
+++ src/main/java/chylex/hee/game/entity/living/ai/path/PathNavigateGroundPreferBeeLine.kt	(date 1601019055659)
@@ -60,7 +60,7 @@
 			}
 		}
 		else if (isBeelining){
-			doBeelineMovement()
+			doBeelineMovement() // TODO avoid falling off blocks too high
 		}
 	}
 	
Index: src/main/java/chylex/hee/init/ModAtlases.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.init\nimport chylex.hee.HEE\nimport chylex.hee.client.render.block.RenderTileDarkChest\nimport chylex.hee.client.render.block.RenderTileLootChest\nimport chylex.hee.game.container.slot.SlotTrinketItem\nimport chylex.hee.system.migration.forge.Side\nimport chylex.hee.system.migration.forge.SubscribeAllEvents\nimport chylex.hee.system.migration.forge.SubscribeEvent\nimport net.minecraft.client.renderer.Atlases\nimport net.minecraft.util.ResourceLocation\nimport net.minecraftforge.client.event.TextureStitchEvent\nimport net.minecraftforge.fml.common.Mod.EventBusSubscriber.Bus.MOD\n\n@SubscribeAllEvents(Side.CLIENT, modid = HEE.ID, bus = MOD)\nobject ModAtlases{\n\tval ATLAS_GUIS: ResourceLocation = Atlases.CHEST_ATLAS\n\tval ATLAS_TILES: ResourceLocation = Atlases.CHEST_ATLAS\n\t\n\t@SubscribeEvent\n\tfun onTextureStitchPre(e: TextureStitchEvent.Pre){\n\t\tif (e.map.textureLocation == ATLAS_GUIS){\n\t\t\te.addSprite(SlotTrinketItem.TEX_SLOT_OVERLAY)\n\t\t}\n\t\t\n\t\tif (e.map.textureLocation == ATLAS_TILES){\n\t\t\te.addSprite(RenderTileDarkChest.TEX_SINGLE)\n\t\t\te.addSprite(RenderTileDarkChest.TEX_DOUBLE_LEFT)\n\t\t\te.addSprite(RenderTileDarkChest.TEX_DOUBLE_RIGHT)\n\t\t\te.addSprite(RenderTileLootChest.TEX)\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/init/ModAtlases.kt	(revision d2db1adf0c9cb6849db18efe50855702922d4745)
+++ src/main/java/chylex/hee/init/ModAtlases.kt	(date 1601019056263)
@@ -6,15 +6,15 @@
 import chylex.hee.system.migration.forge.Side
 import chylex.hee.system.migration.forge.SubscribeAllEvents
 import chylex.hee.system.migration.forge.SubscribeEvent
-import net.minecraft.client.renderer.Atlases
+import chylex.hee.system.util.facades.Resource
 import net.minecraft.util.ResourceLocation
 import net.minecraftforge.client.event.TextureStitchEvent
 import net.minecraftforge.fml.common.Mod.EventBusSubscriber.Bus.MOD
 
 @SubscribeAllEvents(Side.CLIENT, modid = HEE.ID, bus = MOD)
 object ModAtlases{
-	val ATLAS_GUIS: ResourceLocation = Atlases.CHEST_ATLAS
-	val ATLAS_TILES: ResourceLocation = Atlases.CHEST_ATLAS
+	val ATLAS_GUIS: ResourceLocation = Resource.Vanilla("textures/atlas/chest.png") // Atlases.CHEST_ATLAS
+	val ATLAS_TILES: ResourceLocation = Resource.Vanilla("textures/atlas/chest.png") // Atlases.CHEST_ATLAS
 	
 	@SubscribeEvent
 	fun onTextureStitchPre(e: TextureStitchEvent.Pre){
Index: src/main/java/chylex/hee/game/block/BlockEnergyCluster.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.block\nimport chylex.hee.game.block.entity.TileEntityEnergyCluster\nimport chylex.hee.game.block.info.BlockBuilder\nimport chylex.hee.game.mechanics.energy.IEnergyQuantity\nimport chylex.hee.game.mechanics.instability.Instability\nimport chylex.hee.init.ModBlocks\nimport chylex.hee.init.ModItems\nimport chylex.hee.system.migration.forge.Side\nimport chylex.hee.system.migration.forge.Sided\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\nimport chylex.hee.system.migration.vanilla.EntityPlayer\nimport chylex.hee.system.util.allInCenteredSphereMutable\nimport chylex.hee.system.util.ceilToInt\nimport chylex.hee.system.util.floorToInt\nimport chylex.hee.system.util.getTile\nimport chylex.hee.system.util.nextFloat\nimport chylex.hee.system.util.removeBlock\nimport net.minecraft.block.BlockRenderType.INVISIBLE\nimport net.minecraft.block.BlockState\nimport net.minecraft.client.particle.ParticleManager\nimport net.minecraft.entity.Entity\nimport net.minecraft.entity.IProjectile\nimport net.minecraft.item.ItemStack\nimport net.minecraft.tileentity.TileEntity\nimport net.minecraft.util.math.AxisAlignedBB\nimport net.minecraft.util.math.BlockPos\nimport net.minecraft.util.math.RayTraceResult\nimport net.minecraft.util.math.shapes.ISelectionContext\nimport net.minecraft.util.math.shapes.VoxelShape\nimport net.minecraft.util.math.shapes.VoxelShapes\nimport net.minecraft.world.Explosion.Mode\nimport net.minecraft.world.IBlockReader\nimport net.minecraft.world.World\nimport net.minecraft.world.server.ServerWorld\nimport kotlin.math.pow\n\nclass BlockEnergyCluster(builder: BlockBuilder) : BlockSimpleShaped(builder, AxisAlignedBB(0.2, 0.2, 0.2, 0.8, 0.8, 0.8)){\n\tcompanion object{\n\t\tfun createSmallLeak(world: World, pos: BlockPos, amount: IEnergyQuantity, causeInstability: Boolean = false){\n\t\t\tval units = amount.units.value.toFloat()\n\t\t\tval corruptedEnergyLevel = (2F + (units.pow(0.74F) / 9F)).ceilToInt()\n\t\t\t\n\t\t\tModBlocks.CORRUPTED_ENERGY.spawnCorruptedEnergy(world, pos, corruptedEnergyLevel)\n\t\t\t\n\t\t\tif (causeInstability){\n\t\t\t\tInstability.get(world).triggerAction((10 + 2 * corruptedEnergyLevel).toUShort(), pos)\n\t\t\t}\n\t\t}\n\t\t\n\t\tfun createFullLeak(world: World, pos: BlockPos, amount: IEnergyQuantity){\n\t\t\tval units = amount.units.value.toFloat()\n\t\t\t\n\t\t\tval corruptedEnergyRadius = 1.5 + (units.pow(0.77F) / 70F)\n\t\t\tval corruptedEnergyLevel = (2F + (units.pow(0.74F) / 9F)).ceilToInt()\n\t\t\t\n\t\t\tfor(testPos in pos.allInCenteredSphereMutable(corruptedEnergyRadius)){\n\t\t\t\tModBlocks.CORRUPTED_ENERGY.spawnCorruptedEnergy(world, testPos, corruptedEnergyLevel)\n\t\t\t}\n\t\t}\n\t}\n\t\n\toverride fun hasTileEntity(state: BlockState): Boolean{\n\t\treturn true\n\t}\n\t\n\toverride fun createTileEntity(state: BlockState, world: IBlockReader): TileEntity{\n\t\treturn TileEntityEnergyCluster()\n\t}\n\t\n\toverride fun onBlockHarvested(world: World, pos: BlockPos, state: BlockState, player: EntityPlayer){\n\t\tif (player.abilities.isCreativeMode && !player.isSneaking){\n\t\t\tpos.getTile<TileEntityEnergyCluster>(world)?.breakWithoutExplosion = true\n\t\t}\n\t}\n\t\n\toverride fun onReplaced(state: BlockState, world: World, pos: BlockPos, newState: BlockState, isMoving: Boolean){\n\t\tval tile = pos.getTile<TileEntityEnergyCluster>(world) ?: return\n\t\tsuper.onReplaced(state, world, pos, newState, isMoving) // removes the tile entity\n\t\t\n\t\tif (tile.breakWithoutExplosion){\n\t\t\treturn\n\t\t}\n\t\t\n\t\tval level = tile.energyLevel\n\t\tval units = level.units.value.toFloat()\n\t\t\n\t\tval explosionStength = 2.5F + (units.pow(0.6F) * 0.1F)\n\t\tval ethereumToDrop = (world.rand.nextFloat(1.6F, 2.0F) * (units * 0.01F).pow(1.4F)).floorToInt()\n\t\t\n\t\tworld.createExplosion(null, pos.x + 0.5, pos.y + 0.5, pos.z + 0.5, explosionStength, false, Mode.DESTROY)\n\t\t\n\t\tInstability.get(world).triggerAction((100F + units.pow(0.785F)).ceilToInt().toUShort(), pos)\n\t\tcreateFullLeak(world, pos, level)\n\t\t\n\t\trepeat(ethereumToDrop){\n\t\t\tspawnAsEntity(world, pos, ItemStack(ModItems.ETHEREUM))\n\t\t}\n\t}\n\t\n\toverride fun onEntityCollision(state: BlockState, world: World, pos: BlockPos, entity: Entity){\n\t\tif (entity is IProjectile){\n\t\t\tpos.removeBlock(world)\n\t\t}\n\t}\n\t\n\t@Sided(Side.CLIENT) override fun addHitEffects(state: BlockState, world: World, target: RayTraceResult, manager: ParticleManager) = true\n\t@Sided(Side.CLIENT) override fun addDestroyEffects(state: BlockState, world: World, pos: BlockPos, manager: ParticleManager) = true\n\t@Sided(Side.CLIENT) override fun addRunningEffects(state: BlockState, world: World, pos: BlockPos, entity: Entity) = true\n\t@Sided(Side.CLIENT) override fun addLandingEffects(state: BlockState, world: ServerWorld, pos: BlockPos, stateAgain: BlockState, entity: EntityLivingBase, particleAmount: Int) = true\n\t\n\toverride fun getCollisionShape(state: BlockState, world: IBlockReader, pos: BlockPos, context: ISelectionContext): VoxelShape{\n\t\treturn VoxelShapes.empty()\n\t}\n\t\n\toverride fun getRenderType(state: BlockState) = INVISIBLE\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/block/BlockEnergyCluster.kt	(revision d2db1adf0c9cb6849db18efe50855702922d4745)
+++ src/main/java/chylex/hee/game/block/BlockEnergyCluster.kt	(date 1601019054929)
@@ -1,6 +1,7 @@
 package chylex.hee.game.block
 import chylex.hee.game.block.entity.TileEntityEnergyCluster
 import chylex.hee.game.block.info.BlockBuilder
+import chylex.hee.game.mechanics.energy.IClusterGenerator
 import chylex.hee.game.mechanics.energy.IEnergyQuantity
 import chylex.hee.game.mechanics.instability.Instability
 import chylex.hee.init.ModBlocks
@@ -67,6 +68,10 @@
 		return TileEntityEnergyCluster()
 	}
 	
+	override fun onBlockPlacedBy(world: World, pos: BlockPos, state: BlockState, placer: EntityLivingBase?, stack: ItemStack){
+		pos.getTile<TileEntityEnergyCluster>(world)?.loadClusterSnapshot(IClusterGenerator.ENERGY_SHRINE.generate(world.rand), inactive = false)
+	}
+	
 	override fun onBlockHarvested(world: World, pos: BlockPos, state: BlockState, player: EntityPlayer){
 		if (player.abilities.isCreativeMode && !player.isSneaking){
 			pos.getTile<TileEntityEnergyCluster>(world)?.breakWithoutExplosion = true
Index: src/main/java/chylex/hee/game/entity/living/EntityMobBlobby.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.living\nimport chylex.hee.game.entity.living.ai.AIFollowLeaderJumping\nimport chylex.hee.game.entity.living.ai.AIPickUpItemDetour\nimport chylex.hee.game.entity.living.ai.AIWanderLand\nimport chylex.hee.game.entity.living.ai.AIWatchDyingLeader\nimport chylex.hee.game.entity.living.ai.AIWatchIdleJumping\nimport chylex.hee.game.entity.living.ai.path.PathNavigateGroundPreferBeeLine\nimport chylex.hee.game.entity.living.ai.util.AIToggle\nimport chylex.hee.game.entity.living.ai.util.AIToggle.Companion.addGoal\nimport chylex.hee.game.entity.living.behavior.BlobbyItemPickupHandler\nimport chylex.hee.game.entity.living.helpers.EntityBodyHeadOnly\nimport chylex.hee.game.entity.living.helpers.EntityLookWhileJumping\nimport chylex.hee.game.entity.living.helpers.EntityMoveJumping\nimport chylex.hee.game.entity.util.ColorDataSerializer\nimport chylex.hee.game.entity.util.EntityData\nimport chylex.hee.init.ModEntities\nimport chylex.hee.init.ModItems\nimport chylex.hee.system.migration.vanilla.EntityCreature\nimport chylex.hee.system.migration.vanilla.EntityPlayer\nimport chylex.hee.system.migration.vanilla.ItemSword\nimport chylex.hee.system.migration.vanilla.Sounds\nimport chylex.hee.system.util.AISwim\nimport chylex.hee.system.util.Pos\nimport chylex.hee.system.util.TagCompound\nimport chylex.hee.system.util.Vec3\nimport chylex.hee.system.util.addY\nimport chylex.hee.system.util.blocksMovement\nimport chylex.hee.system.util.ceilToInt\nimport chylex.hee.system.util.color.IntColor\nimport chylex.hee.system.util.color.IntColor.Companion.HCL\nimport chylex.hee.system.util.color.IntColor.Companion.RGB\nimport chylex.hee.system.util.facades.Resource\nimport chylex.hee.system.util.getFloatOrNull\nimport chylex.hee.system.util.getIntegerOrNull\nimport chylex.hee.system.util.getStack\nimport chylex.hee.system.util.heeTag\nimport chylex.hee.system.util.isNotEmpty\nimport chylex.hee.system.util.math.LerpedFloat\nimport chylex.hee.system.util.nextFloat\nimport chylex.hee.system.util.nextInt\nimport chylex.hee.system.util.nextItem\nimport chylex.hee.system.util.nextVector2\nimport chylex.hee.system.util.offsetTowards\nimport chylex.hee.system.util.posVec\nimport chylex.hee.system.util.putStack\nimport chylex.hee.system.util.scale\nimport chylex.hee.system.util.selectEntities\nimport chylex.hee.system.util.selectExistingEntities\nimport chylex.hee.system.util.square\nimport chylex.hee.system.util.use\nimport chylex.hee.system.util.withY\nimport net.minecraft.entity.Entity\nimport net.minecraft.entity.EntitySize\nimport net.minecraft.entity.EntityType\nimport net.minecraft.entity.ILivingEntityData\nimport net.minecraft.entity.Pose\nimport net.minecraft.entity.SharedMonsterAttributes.FOLLOW_RANGE\nimport net.minecraft.entity.SharedMonsterAttributes.MAX_HEALTH\nimport net.minecraft.entity.SharedMonsterAttributes.MOVEMENT_SPEED\nimport net.minecraft.entity.SpawnReason\nimport net.minecraft.entity.SpawnReason.SPAWN_EGG\nimport net.minecraft.entity.ai.controller.BodyController\nimport net.minecraft.item.ItemStack\nimport net.minecraft.item.UseAction.SPEAR\nimport net.minecraft.nbt.CompoundNBT\nimport net.minecraft.network.IPacket\nimport net.minecraft.network.datasync.DataSerializers\nimport net.minecraft.pathfinding.PathNavigator\nimport net.minecraft.pathfinding.PathNodeType\nimport net.minecraft.potion.Effects.JUMP_BOOST\nimport net.minecraft.util.DamageSource\nimport net.minecraft.util.Hand.MAIN_HAND\nimport net.minecraft.util.Hand.OFF_HAND\nimport net.minecraft.util.ResourceLocation\nimport net.minecraft.util.SoundEvent\nimport net.minecraft.world.DifficultyInstance\nimport net.minecraft.world.IWorld\nimport net.minecraft.world.World\nimport net.minecraftforge.fml.network.NetworkHooks\nimport java.util.Random\nimport kotlin.math.abs\n\nclass EntityMobBlobby(type: EntityType<out EntityCreature>, world: World) : EntityCreature(type, world){\n\t@Suppress(\"unused\")\n\tconstructor(world: World) : this(ModEntities.BLOBBY, world)\n\t\n\tcompanion object{\n\t\tprivate val DATA_SCALE = EntityData.register<EntityMobBlobby, Float>(DataSerializers.FLOAT)\n\t\tprivate val DATA_COLOR = EntityData.register<EntityMobBlobby, IntColor>(ColorDataSerializer)\n\t\tprivate val DATA_HELD_ITEM = EntityData.register<EntityMobBlobby, ItemStack>(DataSerializers.ITEMSTACK)\n\t\t\n\t\tval LOOT_TABLE = Resource.Custom(\"entities/blobby\")\n\t\t\n\t\tprivate const val GROUP_ID_TAG = \"Group\"\n\t\tprivate const val GROUP_LEADER_TAG = \"IsLeader\"\n\t\tprivate const val MAX_HEALTH_TAG = \"MaxHealth\"\n\t\tprivate const val SCALE_TAG = \"Scale\"\n\t\tprivate const val COLOR_TAG = \"Color\"\n\t\tprivate const val JUMP_DELAY_MIN_TAG = \"JumpDelayMin\"\n\t\tprivate const val JUMP_DELAY_MAX_TAG = \"JumpDelayMax\"\n\t\tprivate const val JUMP_SPEED_TAG = \"JumpSpeed\"\n\t\tprivate const val JUMP_HEIGHT_TAG = \"JumpHeight\"\n\t\tprivate const val HELD_ITEM_TAG = \"HeldItem\"\n\t\tprivate const val ITEM_PICKUP_TAG = \"ItemPickup\"\n\t\t\n\t\tprivate val MAX_JUMP_DELAY = Int.MAX_VALUE..Int.MAX_VALUE\n\t\t\n\t\tclass SpawnGroupData(genRand: Random) : ILivingEntityData{\n\t\t\tprivate val rngSeedBase = genRand.nextLong()\n\t\t\tprivate val rngSeedOffset = genRand.nextInt(100, 10000)\n\t\t\t\n\t\t\tprivate val groupId = genRand.nextLong()\n\t\t\tprivate val subGroups = genRand.nextInt(1, 3)\n\t\t\t\n\t\t\tprivate val baseHealth = genRand.nextInt(1, 6).toFloat()\n\t\t\tprivate val leaderHealth = baseHealth + genRand.nextInt(1, 2)\n\t\t\t\n\t\t\tprivate val scales = Array(subGroups){ genRand.nextFloat(0.55F, 1F) }.apply { sortDescending() }\n\t\t\tprivate val hues = Array(subGroups){ genRand.nextFloat(0.0, 360.0) }\n\t\t\t\n\t\t\tprivate val chroma = genRand.nextFloat(80F, 95F)\n\t\t\tprivate val luminance = genRand.nextFloat(51F, 59F)\n\t\t\t\n\t\t\tprivate val jumpDelay = genRand.nextInt(0, 5).let { (genRand.nextInt(8, 10) + it)..(genRand.nextInt(11, 14) + it) }\n\t\t\tprivate val jumpSpeedMp = 1F + (0.025 + (genRand.nextGaussian() * 0.2)).coerceIn(-0.2, 0.3).toFloat()\n\t\t\tprivate val jumpHeightMp = offsetTowards(jumpSpeedMp, 1F, 0.4F) + abs(genRand.nextGaussian() * 0.3).coerceAtMost(0.6).toFloat()\n\t\t\t\n\t\t\tfun setupLeader(blobby: EntityMobBlobby){\n\t\t\t\tblobby.groupId = groupId\n\t\t\t\tblobby.setLeaderStatusAndRefresh(true)\n\t\t\t\t\n\t\t\t\tblobby.setMaxHealth(leaderHealth, resetCurrentHealth = true)\n\t\t\t\tblobby.scale = scales[0]\n\t\t\t\tblobby.color = HCL(hues[0], chroma, luminance)\n\t\t\t\t\n\t\t\t\tblobby.jumpDelay = jumpDelay\n\t\t\t\tblobby.jumpSpeedMp = jumpSpeedMp\n\t\t\t\tblobby.jumpHeightMp = jumpHeightMp\n\t\t\t}\n\t\t\t\n\t\t\tfun generateLeader(world: World) = EntityMobBlobby(world).also(::setupLeader)\n\t\t\t\n\t\t\tfun generateChild(world: World, index: Int) = EntityMobBlobby(world).also {\n\t\t\t\tval rand = Random(rngSeedBase + (index * rngSeedOffset))\n\t\t\t\tval subGroup = rand.nextInt(subGroups)\n\t\t\t\t\n\t\t\t\tit.groupId = groupId\n\t\t\t\t\n\t\t\t\tit.setMaxHealth(baseHealth + rand.nextInt(0, 2), resetCurrentHealth = true)\n\t\t\t\tit.scale = scales[subGroup] * rand.nextFloat(0.91F, 0.99F)\n\t\t\t\t\n\t\t\t\tit.color = HCL(\n\t\t\t\t\thues[subGroup] + rand.nextFloat(-6.0, 6.0),\n\t\t\t\t\tchroma * rand.nextFloat(0.94F, 1.03F),\n\t\t\t\t\tluminance * rand.nextFloat(0.97F, 1.018F)\n\t\t\t\t)\n\t\t\t\t\n\t\t\t\tit.jumpDelay = jumpDelay\n\t\t\t\tit.jumpSpeedMp = jumpSpeedMp * rand.nextFloat(0.93F, 1.06F)\n\t\t\t\tit.jumpHeightMp = jumpHeightMp * rand.nextFloat(0.97F, 1.03F)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Instance\n\t\n\tprivate var groupId = 0L\n\tprivate var isGroupLeader = false\n\t\n\tvar scale by EntityData(DATA_SCALE)\n\t\tprivate set\n\t\n\tvar color by EntityData(DATA_COLOR)\n\t\tprivate set\n\t\n\tprivate var jumpDelay = MAX_JUMP_DELAY\n\tprivate var jumpSpeedMp = 1F\n\tprivate var jumpHeightMp = 1F\n\t\n\tvar heldItem by EntityData(DATA_HELD_ITEM)\n\tprivate lateinit var itemPickupHandler: BlobbyItemPickupHandler\n\t\n\tprivate var isColliding = false\n\tprivate var wasOnGround = false\n\t\n\tval renderSquishClient = LerpedFloat(0F)\n\tprivate var squishTarget = 0F\n\t\n\tprivate lateinit var aiLeaderEnabledToggle: AIToggle\n\tprivate lateinit var aiLeaderDisabledToggle: AIToggle\n\t\n\tprivate val isFollowRangeAreaLoaded\n\t\tget() = world.isAreaLoaded(Pos(this), getAttribute(FOLLOW_RANGE).value.ceilToInt())\n\t\n\t// Initialization\n\t\n\tinit{\n\t\tmoveController = EntityMoveJumping(this, ::getJumpDelay, degreeDiffBeforeMovement = 22.5)\n\t\tlookController = EntityLookWhileJumping(this)\n\t\t\n\t\tsetPathPriority(PathNodeType.WATER, 2F)\n\t\tsetPathPriority(PathNodeType.WATER_BORDER, 4F)\n\t}\n\t\n\toverride fun registerData(){\n\t\tsuper.registerData()\n\t\tdataManager.register(DATA_COLOR, RGB(255u))\n\t\tdataManager.register(DATA_SCALE, 1F)\n\t\tdataManager.register(DATA_HELD_ITEM, ItemStack.EMPTY)\n\t}\n\t\n\toverride fun registerAttributes(){\n\t\tsuper.registerAttributes()\n\t\t\n\t\tgetAttribute(MAX_HEALTH).baseValue = 8.0\n\t\tgetAttribute(MOVEMENT_SPEED).baseValue = 0.19\n\t\tgetAttribute(FOLLOW_RANGE).baseValue = 44.0\n\t\tgetAttribute(ENTITY_GRAVITY).baseValue *= 0.725\n\t\t\n\t\texperienceValue = 1\n\t}\n\t\n\tfun setMaxHealth(maxHealth: Float, resetCurrentHealth: Boolean){\n\t\tgetAttribute(MAX_HEALTH).baseValue = maxHealth.toDouble()\n\t\t\n\t\thealth = if (resetCurrentHealth)\n\t\t\tmaxHealth\n\t\telse\n\t\t\thealth.coerceAtMost(maxHealth)\n\t}\n\t\n\toverride fun registerGoals(){\n\t\taiLeaderEnabledToggle = AIToggle()\n\t\taiLeaderEnabledToggle.enabled = false\n\t\t\n\t\taiLeaderDisabledToggle = AIToggle()\n\t\taiLeaderDisabledToggle.enabled = true\n\t\t\n\t\titemPickupHandler = BlobbyItemPickupHandler(this)\n\t\t\n\t\tgoalSelector.addGoal(1, AISwim(this))\n\t\tgoalSelector.addGoal(2, AIWatchDyingLeader(this, ticksBeforeResuming = 49), aiLeaderDisabledToggle)\n\t\tgoalSelector.addGoal(3, AIPickUpItemDetour(this, chancePerTick = 100, maxDetourTicks = 65..200, searchRadius = 8.0, speedMp = 1.25, handler = itemPickupHandler))\n\t\tgoalSelector.addGoal(4, AIWanderLand(this, movementSpeed = 1.0, chancePerTick = 45, maxDistanceXZ = 22, maxDistanceY = 6), aiLeaderEnabledToggle)\n\t\tgoalSelector.addGoal(4, AIFollowLeaderJumping(this), aiLeaderDisabledToggle)\n\t\tgoalSelector.addGoal(5, AIWatchIdleJumping(this, chancePerTick = 0.07F, delayTicks = 13))\n\t}\n\t\n\toverride fun createSpawnPacket(): IPacket<*>{\n\t\treturn NetworkHooks.getEntitySpawningPacket(this)\n\t}\n\t\n\t// Leadership\n\t\n\tprivate fun setLeaderStatusAndRefresh(isLeader: Boolean){\n\t\tisGroupLeader = isLeader\n\t\taiLeaderEnabledToggle.enabled = isLeader\n\t\taiLeaderDisabledToggle.enabled = !isLeader\n\t}\n\t\n\tprivate fun recreateGroup(){\n\t\tval originalGroup = world\n\t\t\t.selectExistingEntities\n\t\t\t.inRange<EntityMobBlobby>(posVec, getAttribute(FOLLOW_RANGE).value)\n\t\t\t.filter { it.groupId == groupId }\n\t\t\t.ifEmpty { listOf(this) }\n\t\t\n\t\tval newGroupLimit = rand.nextInt(1, rand.nextInt(1, originalGroup.size))\n\t\tval newGroups = Array(newGroupLimit){ mutableListOf<EntityMobBlobby>() }\n\t\t\n\t\tfor(peer in originalGroup){\n\t\t\trand.nextItem(newGroups).add(peer)\n\t\t}\n\t\t\n\t\tfor(group in newGroups){\n\t\t\tif (group.isEmpty()){\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tval newId = rand.nextLong()\n\t\t\t\n\t\t\tfor(blobby in group){\n\t\t\t\tblobby.groupId = newId\n\t\t\t}\n\t\t\t\n\t\t\tgroup.maxByOrNull { it.scale }?.setLeaderStatusAndRefresh(isLeader = true)\n\t\t}\n\t}\n\t\n\tfun findLeader(): EntityMobBlobby?{\n\t\tval maxDist = getAttribute(FOLLOW_RANGE).value\n\t\tval checkArea = boundingBox.grow(maxDist, maxDist * 0.5, maxDist)\n\t\t\n\t\treturn world.selectEntities.inBox<EntityMobBlobby>(checkArea).firstOrNull { it.groupId == groupId && it.isGroupLeader && it !== this }\n\t}\n\t\n\t// Behavior\n\t\n\toverride fun livingTick(){\n\t\tsuper.livingTick()\n\t\t\n\t\tif (world.isRemote){\n\t\t\tif (wasOnGround && !onGround){\n\t\t\t\tsquishTarget = 0.175F\n\t\t\t}\n\t\t\telse if (!wasOnGround && onGround){\n\t\t\t\tsquishTarget = -0.15F\n\t\t\t}\n\t\t\t\n\t\t\trenderSquishClient.update(offsetTowards(renderSquishClient.currentValue, squishTarget, 0.6F))\n\t\t\tsquishTarget *= 0.75F\n\t\t}\n\t\telse{\n\t\t\titemPickupHandler.update()\n\t\t\t\n\t\t\tif (ticksExisted % 20 == 0 && heldItem.let { it.item is ItemSword || it.useAction == SPEAR }){\n\t\t\t\tval dangerousItemName = heldItem.item.registryName!!.toString()\n\t\t\t\t\n\t\t\t\tfor(blobby in world.selectEntities.inRange<EntityMobBlobby>(posVec, 12.0)){\n\t\t\t\t\tif (blobby === this || blobby.canEntityBeSeen(this)){\n\t\t\t\t\t\tblobby.itemPickupHandler.banItem(dangerousItemName)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tattackEntityFrom(DamageSource.GENERIC, 1F)\n\t\t\t}\n\t\t\t\n\t\t\tif (ticksExisted % 10 == 0){\n\t\t\t\tif (isGroupLeader){\n\t\t\t\t\tidleTime = if (isFollowRangeAreaLoaded) 0 else 1000\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tidleTime = 0\n\t\t\t\t\t\n\t\t\t\t\tif (findLeader() == null && goalSelector.runningGoals.noneMatch { it.goal is AIWatchDyingLeader } && isFollowRangeAreaLoaded){\n\t\t\t\t\t\trecreateGroup()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twasOnGround = onGround\n\t}\n\t\n\toverride fun applyEntityCollision(other: Entity){\n\t\tif (other is EntityMobBlobby){\n\t\t\tisColliding = true\n\t\t\tother.isColliding = true\n\t\t\t\n\t\t\tsuper.applyEntityCollision(other)\n\t\t\t\n\t\t\tother.isColliding = false\n\t\t\tisColliding = false\n\t\t}\n\t\telse{\n\t\t\tsuper.applyEntityCollision(other)\n\t\t}\n\t}\n\t\n\toverride fun addVelocity(x: Double, y: Double, z: Double){\n\t\tif (isColliding && isGroupLeader){\n\t\t\treturn\n\t\t}\n\t\t\n\t\tsuper.addVelocity(x, y, z)\n\t}\n\t\n\t// Movement\n\t\n\toverride fun createNavigator(world: World): PathNavigator{\n\t\treturn PathNavigateGroundPreferBeeLine(this, world, maxStuckTicks = 55, fallbackPathfindingResetTicks = 70..110)\n\t}\n\t\n\toverride fun createBodyController(): BodyController{\n\t\treturn EntityBodyHeadOnly(this)\n\t}\n\t\n\toverride fun setAIMoveSpeed(speed: Float){\n\t\tsuper.setAIMoveSpeed(if (isInWater) speed * 1.175F else speed * jumpSpeedMp)\n\t}\n\t\n\toverride fun getHorizontalFaceSpeed(): Int{\n\t\treturn 15\n\t}\n\t\n\toverride fun getFaceRotSpeed(): Int{\n\t\treturn 15\n\t}\n\t\n\tprivate fun getJumpDelay(): Int{\n\t\tval delayReduction = when{\n\t\t\tisGroupLeader                           -> 0\n\t\t\titemPickupHandler.catchUpBonusTicks > 0 -> 9\n\t\t\telse                                    -> 4\n\t\t}\n\t\t\n\t\treturn (rand.nextInt(jumpDelay) - delayReduction).coerceAtLeast(5)\n\t}\n\t\n\toverride fun getJumpUpwardsMotion(): Float{\n\t\treturn 0.42F * jumpHeightMp * super.getJumpUpwardsMotion()\n\t}\n\t\n\toverride fun jump(){\n\t\tval baseMotion = jumpUpwardsMotion.toDouble()\n\t\tval lookVec = Vec3.fromYaw(rotationYawHead)\n\t\t\n\t\tval upwardsMotion = if (aiMoveSpeed > 0.1F && (collidedHorizontally || Pos(posVec.addY(height * 0.5).add(lookVec)).let { it.blocksMovement(world) && !it.up().blocksMovement(world) }))\n\t\t\t0.36 + (baseMotion * 0.15)\n\t\telse\n\t\t\tbaseMotion\n\t\t\n\t\tmotion = motion.withY(upwardsMotion + ((getActivePotionEffect(JUMP_BOOST)?.let { it.amplifier + 1 } ?: 0) * 0.1)).add(lookVec.scale(aiMoveSpeed))\n\t\tisAirBorne = true\n\t}\n\t\n\t// Death\n\t\n\toverride fun dropInventory(){\n\t\tsuper.dropInventory()\n\t\t\n\t\tif (heldItem.isNotEmpty){\n\t\t\tentityDropItem(heldItem)\n\t\t}\n\t}\n\t\n\t// Spawning\n\t\n\toverride fun onInitialSpawn(world: IWorld, difficulty: DifficultyInstance, reason: SpawnReason, data: ILivingEntityData?, nbt: CompoundNBT?): ILivingEntityData?{\n\t\tval rand = world.random\n\t\tval wrld = world.world\n\t\tval group = (data as? SpawnGroupData) ?: SpawnGroupData(rand)\n\t\t\n\t\tgroup.setupLeader(this)\n\t\t\n\t\tif (reason == SPAWN_EGG){\n\t\t\tval probableSpawningPlayer = world\n\t\t\t\t.selectExistingEntities\n\t\t\t\t.inRange<EntityPlayer>(posVec, 10.0)\n\t\t\t\t.filter { it.getHeldItem(MAIN_HAND).item === ModItems.SPAWN_BLOBBY || it.getHeldItem(OFF_HAND).item === ModItems.SPAWN_BLOBBY }\n\t\t\t\t.minBy(::getDistanceSq)\n\t\t\t\n\t\t\tif (probableSpawningPlayer == null || !probableSpawningPlayer.isSneaking){\n\t\t\t\trepeat(rand.nextInt(1, 7)){\n\t\t\t\t\tgroup.generateChild(wrld, it).apply {\n\t\t\t\t\t\tcopyLocationAndAnglesFrom(this@EntityMobBlobby)\n\t\t\t\t\t\tposVec = posVec.add(rand.nextVector2(xz = 0.01, y = 0.0))\n\t\t\t\t\t\tworld.addEntity(this)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn super.onInitialSpawn(world, difficulty, reason, group, nbt)\n\t}\n\t\n\t// Despawning\n\t\n\toverride fun checkDespawn(){}\n\t\n\t// Properties\n\t\n\toverride fun getLootTable(): ResourceLocation{\n\t\treturn LOOT_TABLE\n\t}\n\t\n\toverride fun getExperiencePoints(player: EntityPlayer): Int{\n\t\treturn rand.nextInt(0, experienceValue)\n\t}\n\t\n\toverride fun getStandingEyeHeight(pose: Pose, size: EntitySize): Float{\n\t\treturn size.height * 0.575F\n\t}\n\t\n\toverride fun getSoundVolume(): Float{\n\t\treturn 0.5F\n\t}\n\t\n\toverride fun getSoundPitch(): Float{\n\t\treturn 1.5F\n\t}\n\t\n\toverride fun getHurtSound(source: DamageSource): SoundEvent{\n\t\treturn Sounds.ENTITY_SLIME_HURT_SMALL\n\t}\n\t\n\toverride fun getDeathSound(): SoundEvent{\n\t\treturn Sounds.ENTITY_SLIME_DEATH_SMALL\n\t}\n\t\n\toverride fun isInRangeToRenderDist(distanceSq: Double): Boolean{\n\t\treturn distanceSq < square(96.0)\n\t}\n\t\n\t// Serialization\n\t\n\toverride fun writeAdditional(nbt: TagCompound) = nbt.heeTag.use {\n\t\tsuper.writeAdditional(nbt)\n\t\t\n\t\tputLong(GROUP_ID_TAG, groupId)\n\t\tputBoolean(GROUP_LEADER_TAG, isGroupLeader)\n\t\t\n\t\tputFloat(MAX_HEALTH_TAG, maxHealth)\n\t\tputFloat(SCALE_TAG, scale)\n\t\tputInt(COLOR_TAG, color.i)\n\t\t\n\t\tputByte(JUMP_DELAY_MIN_TAG, jumpDelay.first.toByte())\n\t\tputByte(JUMP_DELAY_MAX_TAG, jumpDelay.last.toByte())\n\t\tputFloat(JUMP_SPEED_TAG, jumpSpeedMp)\n\t\tputFloat(JUMP_HEIGHT_TAG, jumpHeightMp)\n\t\t\n\t\tputStack(HELD_ITEM_TAG, heldItem)\n\t\tput(ITEM_PICKUP_TAG, itemPickupHandler.serializeNBT())\n\t}\n\t\n\toverride fun readAdditional(nbt: TagCompound) = nbt.heeTag.use {\n\t\tsuper.readAdditional(nbt)\n\t\t\n\t\tgroupId = getLong(GROUP_ID_TAG)\n\t\tsetLeaderStatusAndRefresh(getBoolean(GROUP_LEADER_TAG))\n\t\t\n\t\tsetMaxHealth(getFloatOrNull(MAX_HEALTH_TAG) ?: maxHealth, resetCurrentHealth = false)\n\t\tscale = getFloatOrNull(SCALE_TAG) ?: scale\n\t\tcolor = IntColor(getIntegerOrNull(COLOR_TAG) ?: color.i)\n\t\t\n\t\tjumpDelay = getByte(JUMP_DELAY_MIN_TAG)..getByte(JUMP_DELAY_MAX_TAG)\n\t\tjumpSpeedMp = getFloat(JUMP_SPEED_TAG)\n\t\tjumpHeightMp = getFloat(JUMP_HEIGHT_TAG)\n\t\t\n\t\theldItem = getStack(HELD_ITEM_TAG)\n\t\titemPickupHandler.deserializeNBT(getCompound(ITEM_PICKUP_TAG))\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/living/EntityMobBlobby.kt	(revision d2db1adf0c9cb6849db18efe50855702922d4745)
+++ src/main/java/chylex/hee/game/entity/living/EntityMobBlobby.kt	(date 1601023909305)
@@ -259,6 +259,8 @@
 	}
 	
 	private fun recreateGroup(){
+		println("newgroup $posX,$posY,$posZ") //TODO
+		
 		val originalGroup = world
 			.selectExistingEntities
 			.inRange<EntityMobBlobby>(posVec, getAttribute(FOLLOW_RANGE).value)
