Index: src/main/java/chylex/hee/game/entity/living/behavior/EnderEyeAttack.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.living.behavior\nimport chylex.hee.game.entity.living.EntityBossEnderEye\nimport chylex.hee.game.entity.lookDirVec\nimport chylex.hee.game.entity.lookPosVec\nimport chylex.hee.game.entity.motionX\nimport chylex.hee.game.entity.motionZ\nimport chylex.hee.game.entity.selectVulnerableEntities\nimport chylex.hee.game.mechanics.damage.Damage\nimport chylex.hee.game.world.totalTime\nimport chylex.hee.network.client.PacketClientLaunchInstantly\nimport chylex.hee.system.math.Vec3\nimport chylex.hee.system.math.addY\nimport chylex.hee.system.math.directionTowards\nimport chylex.hee.system.math.square\nimport chylex.hee.system.math.toRadians\nimport chylex.hee.system.math.withY\nimport chylex.hee.system.migration.EntityLivingBase\nimport chylex.hee.system.migration.EntityPlayer\nimport chylex.hee.system.random.nextFloat\nimport net.minecraft.util.math.AxisAlignedBB\nimport java.util.UUID\nimport kotlin.math.abs\nimport kotlin.math.cos\n\nsealed class EnderEyeAttack{\n\tabstract val damageType: Damage\n\tabstract val damageMultiplier: Float\n\tabstract val canTakeKnockback: Boolean\n\tabstract fun tick(entity: EntityBossEnderEye): Boolean\n\t\n\tclass Melee : EnderEyeAttack(){\n\t\toverride val damageType\n\t\t\tget() = EntityBossEnderEye.DAMAGE_MELEE\n\t\t\n\t\toverride val damageMultiplier\n\t\t\tget() = 1F\n\t\t\n\t\toverride val canTakeKnockback = true\n\t\tprivate var movementSpeed = 1.0\n\t\tprivate var lastAttackTime = 0L\n\t\t\n\t\toverride fun tick(entity: EntityBossEnderEye): Boolean = with(entity){\n\t\t\tval target = attackTarget ?: forceFindNewTarget()\n\t\t\t\n\t\t\tif (target == null){\n\t\t\t\tarmPosition = EntityBossEnderEye.ARMS_LIMP\n\t\t\t\taiMoveSpeed = 0F\n\t\t\t\tsetRotateTarget(null)\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarmPosition = EntityBossEnderEye.ARMS_HUG\n\t\t\t\tlookController.setLookPositionWithEntity(target, 0F, 0F)\n\t\t\t\tsetRotateTarget(target)\n\t\t\t\t\n\t\t\t\tval currentVec = lookPosVec\n\t\t\t\tval targetVec = target.lookPosVec\n\t\t\t\tval distSq = targetVec.squareDistanceTo(currentVec)\n\t\t\t\t\n\t\t\t\tif (distSq > square(6.0 - ((movementSpeed - 1.0) / 1.5))){\n\t\t\t\t\tif (movementSpeed < 3.5){\n\t\t\t\t\t\tmovementSpeed = (movementSpeed + 0.1).coerceAtMost(3.5)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnavigator.tryMoveToXYZ(targetVec.x, targetVec.y + (movementSpeed - 1.0) * 0.6, targetVec.z, movementSpeed)\n\t\t\t\t}\n\t\t\t\telse if (distSq > square(1.2)){\n\t\t\t\t\tif (movementSpeed > 1.0){\n\t\t\t\t\t\tmovementSpeed = (movementSpeed - 0.3).coerceAtLeast(1.0)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnavigator.tryMoveToXYZ(targetVec.x, targetVec.y, targetVec.z, movementSpeed)\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (currentVec.directionTowards(targetVec).dotProduct(motion.normalize()) > 0.0){\n\t\t\t\t\t\tmotion = motion.scale(0.4)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (distSq < square(1.4)){\n\t\t\t\t\tval currentTime = world.totalTime\n\t\t\t\t\t\n\t\t\t\t\tif (currentTime - lastAttackTime >= 20L){\n\t\t\t\t\t\tlastAttackTime = currentTime\n\t\t\t\t\t\tattackEntityAsMob(target)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true\n\t\t}\n\t\t\n\t\tfun reset(entity: EntityBossEnderEye){\n\t\t\tmovementSpeed = 1.0\n\t\t\tlastAttackTime = entity.world.totalTime\n\t\t}\n\t}\n\t\n\tclass KnockbackDash : EnderEyeAttack(){\n\t\toverride val damageType\n\t\t\tget() = EntityBossEnderEye.DAMAGE_DASH\n\t\t\n\t\toverride val damageMultiplier\n\t\t\tget() = 2F\n\t\t\n\t\toverride val canTakeKnockback = false\n\t\t\n\t\tprivate var isSlowingDown = true\n\t\tprivate var attackTimer = 0\n\t\tprivate var attackRepeats = 0\n\t\tprivate val hitEntities = mutableSetOf<UUID>()\n\t\t\n\t\toverride fun tick(entity: EntityBossEnderEye): Boolean = with(entity){\n\t\t\tval target = attackTarget ?: return false\n\t\t\t\n\t\t\tif (isSlowingDown){\n\t\t\t\tarmPosition = EntityBossEnderEye.ARMS_ATTACK\n\t\t\t\taiMoveSpeed = 0F\n\t\t\t\tsetRotateTarget(target)\n\t\t\t\t\n\t\t\t\tif (motion.withY(0.0).lengthSquared() < square(0.05)){\n\t\t\t\t\tif (attackRepeats == 0){\n\t\t\t\t\t\tisSlowingDown = false\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tval lookDir = lookDirVec\n\t\t\t\t\t\tval targetDir = target.lookPosVec.subtract(lookPosVec).normalize()\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (abs(lookDir.dotProduct(targetDir)) > cos(10.0.toRadians())){\n\t\t\t\t\t\t\tisSlowingDown = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarmPosition = EntityBossEnderEye.ARMS_HUG\n\t\t\t\tsetRotateTarget(null)\n\t\t\t\t\n\t\t\t\tif (attackTimer == 0){\n\t\t\t\t\tmotion = target.lookPosVec.subtract(lookPosVec).scale(rng.nextFloat(0.15, 0.18))\n\t\t\t\t\tattackTimer = 1\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (hitEntities.isNotEmpty()){\n\t\t\t\t\t++attackTimer\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (attackTimer == 24 || motion.withY(0.0).lengthSquared() < square(0.15)){\n\t\t\t\t\tif (health < realMaxHealth * 0.5F && attackRepeats == 0){\n\t\t\t\t\t\t++attackRepeats\n\t\t\t\t\t\tisSlowingDown = true\n\t\t\t\t\t\tattackTimer = 0\n\t\t\t\t\t\thitEntities.clear()\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcauseDamageInFront(this)\n\t\t\t}\n\t\t\t\n\t\t\treturn true\n\t\t}\n\t\t\n\t\tprivate fun causeDamageInFront(entity: EntityBossEnderEye) = with(entity){\n\t\t\tval frontHurtCenter = lookPosVec.add(lookDirVec.scale(width * 0.75))\n\t\t\tval frontHurtDist = width * 0.6\n\t\t\t\n\t\t\tfor(hitEntity in world.selectVulnerableEntities.inBox<EntityLivingBase>(AxisAlignedBB(frontHurtCenter, frontHurtCenter).grow(frontHurtDist))){\n\t\t\t\tif (hitEntity.isNonBoss && !hitEntities.contains(hitEntity.uniqueID) && attackEntityAsMob(hitEntity)){\n\t\t\t\t\tval multiplier = when{\n\t\t\t\t\t\thitEntity.isActiveItemStackBlocking -> 0.25\n\t\t\t\t\t\thitEntity.isSneaking -> 0.75\n\t\t\t\t\t\telse -> 1.0\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tval knockback = Vec3.fromXZ(motionX, motionZ).normalize().scale(0.975 * multiplier).addY(0.075 * multiplier)\n\t\t\t\t\t\n\t\t\t\t\thitEntity.addVelocity(knockback.x, knockback.y, knockback.z)\n\t\t\t\t\thitEntities.add(hitEntity.uniqueID)\n\t\t\t\t\t\n\t\t\t\t\tif (hitEntity is EntityPlayer){\n\t\t\t\t\t\tPacketClientLaunchInstantly(hitEntity, hitEntity.motion).sendToPlayer(hitEntity)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/living/behavior/EnderEyeAttack.kt	(revision 7aa353681181899fd364a859cbeab2f829b5cb82)
+++ src/main/java/chylex/hee/game/entity/living/behavior/EnderEyeAttack.kt	(date 1601492458972)
@@ -95,6 +95,22 @@
 		}
 	}
 	
+	class LaserEye : EnderEyeAttack(){
+		override val damageType
+			get() = EntityBossEnderEye.DAMAGE_LASER
+		
+		override val damageMultiplier
+			get() = 0.75F
+		
+		override val canTakeKnockback = true
+		
+		override fun tick(entity: EntityBossEnderEye): Boolean{
+			TODO("not implemented")
+		}
+		
+		// TODO could switch to a different target randomly if it's within view, could test on an armor stand
+	}
+	
 	class KnockbackDash : EnderEyeAttack(){
 		override val damageType
 			get() = EntityBossEnderEye.DAMAGE_DASH
