Index: src/main/java/chylex/hee/game/block/entity/TileEntityBrewingStandCustom.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.block.entity\r\nimport chylex.hee.game.container.ContainerBrewingStandCustom\r\nimport chylex.hee.game.fx.FxBlockData\r\nimport chylex.hee.game.fx.FxBlockHandler\r\nimport chylex.hee.game.mechanics.potion.brewing.PotionItems\r\nimport chylex.hee.game.particle.ParticleSmokeCustom\r\nimport chylex.hee.game.particle.spawner.ParticleSpawnerCustom\r\nimport chylex.hee.game.particle.util.IOffset.InBox\r\nimport chylex.hee.game.particle.util.IShape.Point\r\nimport chylex.hee.init.ModBlocks\r\nimport chylex.hee.init.ModItems\r\nimport chylex.hee.init.ModTileEntities\r\nimport chylex.hee.network.client.PacketClientFX\r\nimport chylex.hee.system.migration.vanilla.BlockBrewingStand\r\nimport chylex.hee.system.migration.vanilla.Sounds\r\nimport chylex.hee.system.migration.vanilla.TileEntityBrewingStand\r\nimport chylex.hee.system.util.FLAG_SYNC_CLIENT\r\nimport chylex.hee.system.util.color.IRandomColor\r\nimport chylex.hee.system.util.color.IntColor.Companion.RGB\r\nimport chylex.hee.system.util.compatibility.EraseGenerics\r\nimport chylex.hee.system.util.getStack\r\nimport chylex.hee.system.util.getState\r\nimport chylex.hee.system.util.isNotEmpty\r\nimport chylex.hee.system.util.playClient\r\nimport chylex.hee.system.util.playServer\r\nimport chylex.hee.system.util.setStack\r\nimport chylex.hee.system.util.setState\r\nimport net.minecraft.entity.player.PlayerEntity\r\nimport net.minecraft.entity.player.PlayerInventory\r\nimport net.minecraft.inventory.InventoryHelper\r\nimport net.minecraft.inventory.container.Container\r\nimport net.minecraft.item.Item\r\nimport net.minecraft.item.ItemStack\r\nimport net.minecraft.tileentity.TileEntityType\r\nimport net.minecraft.util.Direction\r\nimport net.minecraft.util.NonNullList\r\nimport net.minecraft.util.SoundCategory\r\nimport net.minecraft.util.math.BlockPos\r\nimport net.minecraft.util.text.ITextComponent\r\nimport net.minecraft.util.text.TranslationTextComponent\r\nimport net.minecraft.world.World\r\nimport net.minecraftforge.common.brewing.BrewingRecipeRegistry\r\nimport net.minecraftforge.event.ForgeEventFactory\r\nimport java.util.Arrays\r\nimport java.util.Random\r\n\r\nclass TileEntityBrewingStandCustom : TileEntityBrewingStand(){\r\n\tcompanion object{\r\n\t\tval SLOTS_POTIONS = 0..2\r\n\t\tconst val SLOT_REAGENT = 3\r\n\t\tconst val SLOT_MODIFIER = 4\r\n\t\t\r\n\t\tconst val TOTAL_SLOTS = 5\r\n\t\tconst val TOTAL_FIELDS = 2 // UPDATE 1.15\r\n\t\t\r\n\t\tprivate val POTION_SLOTS = SLOTS_POTIONS.toList().toIntArray()\r\n\t\t\r\n\t\tfun canInsertIntoReagentSlot(stack: ItemStack, isEnhanced: Boolean): Boolean{\r\n\t\t\treturn if (stack.item === ModItems.END_POWDER)\r\n\t\t\t\tisEnhanced\r\n\t\t\telse if (stack.item === ModItems.AMELIOR)\r\n\t\t\t\t!isEnhanced\r\n\t\t\telse\r\n\t\t\t\tPotionItems.isReagent(stack)\r\n\t\t}\r\n\t\t\r\n\t\tfun canInsertIntoModifierSlot(stack: ItemStack): Boolean{\r\n\t\t\treturn PotionItems.isModifier(stack)\r\n\t\t}\r\n\t\t\r\n\t\tprivate val PARTICLE_AMELIORATE = ParticleSpawnerCustom(\r\n\t\t\ttype = ParticleSmokeCustom,\r\n\t\t\tdata = ParticleSmokeCustom.Data(IRandomColor.Static(RGB(180, 46, 214)), lifespan = 10..18, scale = 0.9F),\r\n\t\t\tpos = InBox(-0.325F, 0.325F, -0.4F, 0.25F, -0.3F, 0.325F)\r\n\t\t)\r\n\t\t\r\n\t\tval FX_AMELIORATE = object : FxBlockHandler(){\r\n\t\t\toverride fun handle(pos: BlockPos, world: World, rand: Random){\r\n\t\t\t\tPARTICLE_AMELIORATE.spawn(Point(pos, 21), rand)\r\n\t\t\t\tSounds.BLOCK_BREWING_STAND_BREW.playClient(pos, SoundCategory.BLOCKS, volume = 1.35F, pitch = 1.1F)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tval wrld\r\n\t\tget() = super.world!!\r\n\t\r\n\tval isEnhanced\r\n\t\tget() = blockState.block === ModBlocks.ENHANCED_BREWING_STAND\r\n\t\r\n\tvar brewTime\r\n\t\tget() = field_213954_a.get(0)\r\n\t\tset(value){ field_213954_a.set(0, value) }\r\n\t\r\n\tprivate var prevReagentItem: Item? = null\r\n\tprivate var prevFilledSlots: BooleanArray? = null\r\n\t\r\n\tprivate var playersViewingGUI = 0\r\n\tprivate var ameliorTimer = 0\r\n\t\r\n\toverride fun getType(): TileEntityType<*>{\r\n\t\treturn ModTileEntities.BREWING_STAND\r\n\t}\r\n\t\r\n\toverride fun tick(){\r\n\t\tval canBrew = canBrew()\r\n\t\t\r\n\t\tif (brewTime > 0){\r\n\t\t\tif (!canBrew || prevReagentItem != getStackInSlot(SLOT_REAGENT).item){\r\n\t\t\t\tbrewTime = 0\r\n\t\t\t\tprevReagentItem = null\r\n\t\t\t\tmarkDirty()\r\n\t\t\t}\r\n\t\t\telse if (--brewTime == 0){\r\n\t\t\t\tdoBrew()\r\n\t\t\t\tmarkDirty()\r\n\t\t\t}\r\n\t\t\telse if (isEnhanced && brewTime > 2){\r\n\t\t\t\t--brewTime // double brewing speed\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (canBrew){\r\n\t\t\tbrewTime = 400\r\n\t\t\tprevReagentItem = getStack(SLOT_REAGENT).item\r\n\t\t\tmarkDirty()\r\n\t\t}\r\n\t\t\r\n\t\tif (!wrld.isRemote){\r\n\t\t\tval filledSlots = createFilledSlotsArray()\r\n\t\t\t\r\n\t\t\tif (!Arrays.equals(prevFilledSlots, filledSlots)){\r\n\t\t\t\tprevFilledSlots = filledSlots\r\n\t\t\t\t\r\n\t\t\t\tval state = pos.getState(wrld)\r\n\t\t\t\t\r\n\t\t\t\tif (state.block is BlockBrewingStand){\r\n\t\t\t\t\tpos.setState(wrld, filledSlots.zip(BlockBrewingStand.HAS_BOTTLE).fold(state){ acc, (on, prop) -> acc.with(prop, on) }, FLAG_SYNC_CLIENT)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!isEnhanced && getStack(SLOT_REAGENT).item === ModItems.AMELIOR && playersViewingGUI == 0){\r\n\t\t\t\tif (++ameliorTimer > 25){\r\n\t\t\t\t\tgetStack(SLOT_REAGENT).shrink(1)\r\n\t\t\t\t\t\r\n\t\t\t\t\tval prevState = pos.getState(wrld)\r\n\t\t\t\t\tval newState = prevState.properties.fold(ModBlocks.ENHANCED_BREWING_STAND.defaultState){ acc, prop -> EraseGenerics.copyProperty(acc, prevState, prop) }\r\n\t\t\t\t\t\r\n\t\t\t\t\tpos.setState(wrld, newState, FLAG_SYNC_CLIENT)\r\n\t\t\t\t\tmarkDirty()\r\n\t\t\t\t\t\r\n\t\t\t\t\tPacketClientFX(FX_AMELIORATE, FxBlockData(pos)).sendToAllAround(this, 24.0)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (ameliorTimer > 0){\r\n\t\t\t\tameliorTimer = 0\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Brewing\r\n\t\r\n\tprivate fun canBrew(): Boolean{\r\n\t\tif (POTION_SLOTS.all { brewingItemStacks[it].isEmpty }){\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t\r\n\t\tval reagent = getStack(SLOT_REAGENT)\r\n\t\tval endPowder = reagent.item === ModItems.END_POWDER\r\n\t\t\r\n\t\tif (endPowder){\r\n\t\t\tif (!isEnhanced){\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (POTION_SLOTS.any { slot -> brewingItemStacks[slot].let { it.isNotEmpty && !BrewingRecipeRegistry.hasOutput(it, reagent) } }){\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t\r\n\t\tval modifier = PotionItems.findModifier(getStack(SLOT_MODIFIER))\r\n\t\t\r\n\t\tif (modifier != null){\r\n\t\t\tval simulatedInputs = NonNullList.create<ItemStack>()\r\n\t\t\t\r\n\t\t\tfor(stack in brewingItemStacks){\r\n\t\t\t\tsimulatedInputs.add(stack.copy())\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tBrewingRecipeRegistry.brewPotions(simulatedInputs, reagent, POTION_SLOTS)\r\n\t\t\t\r\n\t\t\tif (POTION_SLOTS.any { slot -> simulatedInputs[slot].let { it.isNotEmpty && !modifier.check(it) } }){\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (endPowder){\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t\r\n\t\treturn true\r\n\t}\r\n\t\r\n\tprivate fun doBrew(){\r\n\t\tif (ForgeEventFactory.onPotionAttemptBrew(brewingItemStacks)){\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\tval reagent = getStack(SLOT_REAGENT)\r\n\t\t\r\n\t\tif (reagent.item !== ModItems.END_POWDER){\r\n\t\t\tBrewingRecipeRegistry.brewPotions(brewingItemStacks, reagent, POTION_SLOTS)\r\n\t\t}\r\n\t\t\r\n\t\tuseIngredient(SLOT_REAGENT)\r\n\t\t\r\n\t\tval modifier = PotionItems.findModifier(getStack(SLOT_MODIFIER))\r\n\t\t\r\n\t\tif (modifier != null){\r\n\t\t\tfor(slot in POTION_SLOTS){\r\n\t\t\t\tval potion = brewingItemStacks[slot]\r\n\t\t\t\t\r\n\t\t\t\tif (potion.isNotEmpty){\r\n\t\t\t\t\tbrewingItemStacks[slot] = modifier.apply(potion)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tuseIngredient(SLOT_MODIFIER)\r\n\t\t}\r\n\t\t\r\n\t\tif (!wrld.isRemote){\r\n\t\t\tSounds.BLOCK_BREWING_STAND_BREW.playServer(wrld, pos, SoundCategory.BLOCKS)\r\n\t\t}\r\n\t\t\r\n\t\tForgeEventFactory.onPotionBrewed(brewingItemStacks)\r\n\t}\r\n\t\r\n\tprivate fun useIngredient(slot: Int){\r\n\t\tval stack = getStack(slot)\r\n\t\tval item = stack.item\r\n\t\t\r\n\t\tstack.shrink(1)\r\n\t\t\r\n\t\tif (item.hasContainerItem(stack)){\r\n\t\t\tval container = item.getContainerItem(stack)\r\n\t\t\t\r\n\t\t\tif (stack.isNotEmpty){\r\n\t\t\t\tInventoryHelper.spawnItemStack(wrld, pos.x.toDouble(), pos.y.toDouble(), pos.z.toDouble(), container)\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tsetStack(slot, container)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tsetStack(slot, stack)\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Container\r\n\t\r\n\toverride fun openInventory(player: PlayerEntity){\r\n\t\tsuper.openInventory(player)\r\n\t\t++playersViewingGUI\r\n\t}\r\n\t\r\n\toverride fun closeInventory(player: PlayerEntity){\r\n\t\tsuper.closeInventory(player)\r\n\t\t--playersViewingGUI\r\n\t}\r\n\t\r\n\toverride fun canInsertItem(index: Int, stack: ItemStack, direction: Direction?): Boolean{\r\n\t\treturn super.canInsertItem(index, stack, direction) && (stack.item !== ModItems.AMELIOR || getStack(index).isEmpty) // try to limit Amelior stack to 1 item, it's mostly futile though\r\n\t}\r\n\t\r\n\toverride fun isItemValidForSlot(index: Int, stack: ItemStack): Boolean{\r\n\t\treturn when(index){\r\n\t\t\tSLOT_REAGENT -> canInsertIntoReagentSlot(stack, isEnhanced)\r\n\t\t\tSLOT_MODIFIER -> canInsertIntoModifierSlot(stack)\r\n\t\t\telse -> super.isItemValidForSlot(index, stack)\r\n\t\t}\r\n\t}\r\n\t\r\n\toverride fun createMenu(id: Int, inventory: PlayerInventory): Container{\r\n\t\treturn ContainerBrewingStandCustom(id, inventory, this, field_213954_a, this)\r\n\t}\r\n\t\r\n\toverride fun getDefaultName(): ITextComponent{\r\n\t\treturn if (isEnhanced)\r\n\t\t\tTranslationTextComponent(\"gui.hee.enhanced_brewing_stand.title\")\r\n\t\telse\r\n\t\t\tsuper.getDefaultName()\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/block/entity/TileEntityBrewingStandCustom.kt	(revision 8f737d916101ef6db1e63728ba3f918aa908dc10)
+++ src/main/java/chylex/hee/game/block/entity/TileEntityBrewingStandCustom.kt	(date 1595089557528)
@@ -167,6 +167,8 @@
 		val reagent = getStack(SLOT_REAGENT)
 		val endPowder = reagent.item === ModItems.END_POWDER
 		
+		// TODO perhaps require End Powder even for vanilla recipes if the ingredient is a vanilla modifier
+		
 		if (endPowder){
 			if (!isEnhanced){
 				return false
Index: src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.projectile\r\nimport chylex.hee.HEE\r\nimport chylex.hee.client.sound.MovingSoundSpatialDash\r\nimport chylex.hee.client.util.MC\r\nimport chylex.hee.game.entity.util.SerializedEntity\r\nimport chylex.hee.game.fx.IFxData\r\nimport chylex.hee.game.fx.IFxHandler\r\nimport chylex.hee.game.particle.ParticleFadingSpot\r\nimport chylex.hee.game.particle.ParticleSmokeCustom\r\nimport chylex.hee.game.particle.spawner.ParticleSpawnerCustom\r\nimport chylex.hee.game.particle.util.IOffset.Gaussian\r\nimport chylex.hee.game.particle.util.IOffset.InBox\r\nimport chylex.hee.game.particle.util.IShape.Line\r\nimport chylex.hee.game.particle.util.IShape.Point\r\nimport chylex.hee.game.world.util.BlockEditor\r\nimport chylex.hee.game.world.util.Teleporter\r\nimport chylex.hee.init.ModEntities\r\nimport chylex.hee.init.ModSounds\r\nimport chylex.hee.network.client.PacketClientFX\r\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\r\nimport chylex.hee.system.migration.vanilla.EntityPlayer\r\nimport chylex.hee.system.util.Pos\r\nimport chylex.hee.system.util.TagCompound\r\nimport chylex.hee.system.util.blocksMovement\r\nimport chylex.hee.system.util.ceilToInt\r\nimport chylex.hee.system.util.color.IRandomColor.Companion.IRandomColor\r\nimport chylex.hee.system.util.color.IntColor.Companion.RGB\r\nimport chylex.hee.system.util.component1\r\nimport chylex.hee.system.util.component2\r\nimport chylex.hee.system.util.component3\r\nimport chylex.hee.system.util.directionTowards\r\nimport chylex.hee.system.util.distanceSqTo\r\nimport chylex.hee.system.util.heeTag\r\nimport chylex.hee.system.util.nextInt\r\nimport chylex.hee.system.util.offsetTowards\r\nimport chylex.hee.system.util.playClient\r\nimport chylex.hee.system.util.posVec\r\nimport chylex.hee.system.util.readCompactVec\r\nimport chylex.hee.system.util.scale\r\nimport chylex.hee.system.util.square\r\nimport chylex.hee.system.util.use\r\nimport chylex.hee.system.util.writeCompactVec\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.EntityType\r\nimport net.minecraft.entity.IProjectile\r\nimport net.minecraft.entity.MoverType.SELF\r\nimport net.minecraft.entity.projectile.ProjectileHelper\r\nimport net.minecraft.network.IPacket\r\nimport net.minecraft.network.PacketBuffer\r\nimport net.minecraft.util.SoundCategory\r\nimport net.minecraft.util.math.BlockPos\r\nimport net.minecraft.util.math.BlockRayTraceResult\r\nimport net.minecraft.util.math.EntityRayTraceResult\r\nimport net.minecraft.util.math.RayTraceContext\r\nimport net.minecraft.util.math.RayTraceContext.BlockMode\r\nimport net.minecraft.util.math.RayTraceContext.FluidMode\r\nimport net.minecraft.util.math.RayTraceResult\r\nimport net.minecraft.util.math.RayTraceResult.Type\r\nimport net.minecraft.util.math.Vec3d\r\nimport net.minecraft.world.World\r\nimport net.minecraftforge.event.ForgeEventFactory\r\nimport net.minecraftforge.fml.network.NetworkHooks\r\nimport java.util.Random\r\n\r\nclass EntityProjectileSpatialDash(type: EntityType<EntityProjectileSpatialDash>, world: World) : Entity(type, world), IProjectile{\r\n\tconstructor(world: World, owner: EntityLivingBase, speedMp: Float, distanceMp: Float) : this(ModEntities.SPATIAL_DASH, world){\r\n\t\tthis.owner = SerializedEntity(owner)\r\n\t\tthis.setPosition(owner.posX, owner.posY + owner.eyeHeight - 0.1, owner.posZ)\r\n\t\t\r\n\t\tval realSpeed = PROJECTILE_SPEED_BASE * speedMp\r\n\t\tval realDistance = PROJECTILE_DISTANCE_BASE * distanceMp\r\n\t\t\r\n\t\tval (dirX, dirY, dirZ) = Vec3d.fromPitchYaw(owner.rotationPitch, owner.rotationYaw)\r\n\t\tshoot(dirX, dirY, dirZ, realSpeed, 0F)\r\n\t\t\r\n\t\tthis.lifespan = (realDistance / realSpeed).ceilToInt().toShort()\r\n\t\tthis.range = realDistance\r\n\t}\r\n\t\r\n\tcompanion object{\r\n\t\tprivate const val PROJECTILE_SPEED_BASE = 1.5F\r\n\t\tprivate const val PROJECTILE_DISTANCE_BASE = 32 // max distance is 98 blocks\r\n\t\t\r\n\t\tprivate const val OWNER_TAG = \"Owner\"\r\n\t\tprivate const val LIFESPAN_TAG = \"Lifespan\"\r\n\t\tprivate const val RANGE_TAG = \"Range\"\r\n\t\t\r\n\t\tprivate val TELEPORT_OFFSETS: Array<BlockPos>\r\n\t\tprivate val TELEPORT = Teleporter(causedInstability = 15u)\r\n\t\t\r\n\t\tprivate val PARTICLE_TICK = ParticleSpawnerCustom(\r\n\t\t\ttype = ParticleFadingSpot,\r\n\t\t\tdata = ParticleFadingSpot.Data(color = IRandomColor { RGB(nextInt(30, 70), nextInt(70, 130), nextInt(100, 200)) }, lifespan = 20..25, scale = (0.1F)..(0.12F)),\r\n\t\t\tpos = InBox(0.2F),\r\n\t\t\tmot = Gaussian(0.008F),\r\n\t\t\tmaxRange = 64.0\r\n\t\t)\r\n\t\t\r\n\t\tprivate val PARTICLE_EXPIRE = ParticleSpawnerCustom(\r\n\t\t\ttype = ParticleSmokeCustom,\r\n\t\t\tdata = ParticleSmokeCustom.Data(color = RGB(240u), scale = 3F),\r\n\t\t\tpos = InBox(0.6F),\r\n\t\t\tmot = Gaussian(0.03F),\r\n\t\t\tmaxRange = 128.0\r\n\t\t)\r\n\t\t\r\n\t\tclass FxExpireData(private val point: Vec3d, private val ownerEntity: Entity?) : IFxData{\r\n\t\t\toverride fun write(buffer: PacketBuffer) = buffer.use {\r\n\t\t\t\twriteCompactVec(point)\r\n\t\t\t\twriteInt(ownerEntity?.entityId ?: -1)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tval FX_EXPIRE = object : IFxHandler<FxExpireData>{\r\n\t\t\toverride fun handle(buffer: PacketBuffer, world: World, rand: Random) = buffer.use {\r\n\t\t\t\tval player = HEE.proxy.getClientSidePlayer() ?: return\r\n\t\t\t\tval playerPos = player.posVec\r\n\t\t\t\t\r\n\t\t\t\tval point = readCompactVec()\r\n\t\t\t\tval forceAudible = readInt() == player.entityId\r\n\t\t\t\t\r\n\t\t\t\tval soundPoint = if (forceAudible){\r\n\t\t\t\t\tval distance = playerPos.distanceTo(point)\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (distance < 10.0){\r\n\t\t\t\t\t\tpoint\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tplayerPos.add(playerPos.directionTowards(point).scale(offsetTowards(10.0, distance, 0.04))) // makes the sound audible even at max distance of ~100 blocks\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tpoint\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tPARTICLE_EXPIRE.spawn(Point(point, 10), rand)\r\n\t\t\t\tModSounds.ENTITY_SPATIAL_DASH_EXPIRE.playClient(soundPoint, SoundCategory.PLAYERS)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tinit{\r\n\t\t\tval offsets = mutableListOf<BlockPos>()\r\n\t\t\t\r\n\t\t\toffsets.add(Pos(0, 2, 0))\r\n\t\t\toffsets.add(Pos(0, 1, 0))\r\n\t\t\t\r\n\t\t\tfor(pos in BlockPos.getAllInBox(Pos(-1, -1, -1), Pos(1, 0, 1))){\r\n\t\t\t\toffsets.add(pos)\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\toffsets.add(Pos(0, -2, 0))\r\n\t\t\t\r\n\t\t\tTELEPORT_OFFSETS = offsets.toTypedArray()\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun canTeleportPlayerOnTop(pos: BlockPos, world: World): Boolean{\r\n\t\t\treturn pos.blocksMovement(world) && !pos.up().blocksMovement(world) && !pos.up(2).blocksMovement(world)\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun handleBlockHit(entity: EntityLivingBase, hit: Vec3d, motion: Vec3d, pos: BlockPos){\r\n\t\t\tif (canTeleportPlayerOnTop(pos, entity.world)){\r\n\t\t\t\tTELEPORT.toBlock(entity, pos.up())\r\n\t\t\t}\r\n\t\t\telse if (!(entity is EntityPlayer && BlockEditor.canBreak(pos, entity))){\r\n\t\t\t\thandleGenericHit(entity, hit, motion)\r\n\t\t\t}\r\n\t\t\telse if (!teleportEntityNear(entity, hit.add(motion.normalize().scale(1.74)), false)){\r\n\t\t\t\thandleGenericHit(entity, hit, motion)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun handleGenericHit(entity: EntityLivingBase, hit: Vec3d, motion: Vec3d){\r\n\t\t\tteleportEntityNear(entity, hit.add(motion.normalize().scale(-1.26)), true)\r\n\t\t}\r\n\t\t\r\n\t\tprivate fun teleportEntityNear(entity: EntityLivingBase, target: Vec3d, fallback: Boolean): Boolean{\r\n\t\t\tval world = entity.world\r\n\t\t\t\r\n\t\t\tval finalBlock = TELEPORT_OFFSETS\r\n\t\t\t\t.map { Pos(target.add(it.x.toDouble(), it.y.toDouble(), it.z.toDouble())) }\r\n\t\t\t\t.sortedBy { it.distanceSqTo(target) }\r\n\t\t\t\t.firstOrNull { canTeleportPlayerOnTop(it, world) }\r\n\t\t\t\r\n\t\t\tif (finalBlock != null){\r\n\t\t\t\tTELEPORT.toBlock(entity, finalBlock.up())\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\telse if (fallback){\r\n\t\t\t\tTELEPORT.toLocation(entity, target)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate var owner = SerializedEntity()\r\n\tprivate var lifespan: Short = 0\r\n\tprivate var range = 0F\r\n\t\r\n\tprivate val cappedMotionVec: Vec3d\r\n\t\tget(){\r\n\t\t\treturn if (motion.length() <= range)\r\n\t\t\t\tmotion\r\n\t\t\telse\r\n\t\t\t\tmotion.normalize().scale(range)\r\n\t\t}\r\n\t\r\n\tinit{\r\n\t\tnoClip = true\r\n\t}\r\n\t\r\n\toverride fun registerData(){}\r\n\t\r\n\toverride fun createSpawnPacket(): IPacket<*>{\r\n\t\treturn NetworkHooks.getEntitySpawningPacket(this)\r\n\t}\r\n\t\r\n\toverride fun shoot(dirX: Double, dirY: Double, dirZ: Double, velocity: Float, inaccuracy: Float){\r\n\t\tthis.motion = Vec3d(dirX, dirY, dirZ).normalize().scale(velocity)\r\n\t}\r\n\t\r\n\toverride fun tick(){\r\n\t\tif (world.isRemote){\r\n\t\t\tif (ticksExisted == 1){\r\n\t\t\t\tMC.instance.soundHandler.play(MovingSoundSpatialDash(this))\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tPARTICLE_TICK.spawn(Line(Vec3d(prevPosX, prevPosY, prevPosZ), posVec, 0.75), rand)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tsuper.tick()\r\n\t\t\r\n\t\tif (!world.isRemote){\r\n\t\t\tval hitObject = determineHitObject()\r\n\t\t\t\r\n\t\t\tif (hitObject != null && hitObject.type != Type.MISS){\r\n\t\t\t\tval ownerEntity = owner.get(world)\r\n\t\t\t\t\r\n\t\t\t\tif (ownerEntity is EntityLivingBase && ownerEntity.world === world){\r\n\t\t\t\t\tif (hitObject is BlockRayTraceResult){\r\n\t\t\t\t\t\thandleBlockHit(ownerEntity, hitObject.hitVec, motion, hitObject.pos)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\thandleGenericHit(ownerEntity, hitObject.hitVec, motion)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tremove()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (--lifespan <= 0){\r\n\t\t\t\tsetExpired()\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\trange -= motion.length().toFloat()\r\n\t\t}\r\n\t\t\r\n\t\tmove(SELF, motion)\r\n\t}\r\n\t\r\n\tprivate fun determineHitObject(): RayTraceResult?{\r\n\t\tval currentPos = posVec\r\n\t\tval nextPos = currentPos.add(cappedMotionVec)\r\n\t\t\r\n\t\tval blockResult = world.rayTraceBlocks(RayTraceContext(currentPos, nextPos, BlockMode.COLLIDER, FluidMode.NONE, this)).takeIf { it.type == Type.BLOCK }\r\n\t\t\r\n\t\tval ownerEntity = owner.get(world)\r\n\t\tval tracedNextPos = blockResult?.hitVec ?: nextPos\r\n\t\t\r\n\t\tval entityResult = ProjectileHelper.rayTraceEntities(world, this, currentPos, nextPos, boundingBox.expand(motion).grow(1.0)){\r\n\t\t\t// the projectile itself cannot collide with anything, therefore not even itself\r\n\t\t\tit.canBeCollidedWith() && !it.isSpectator && it !== ownerEntity\r\n\t\t}?.let {\r\n\t\t\t// ProjectileHelper sets hitVec to the bottom of the entity, but that wouldn't work too nicely here\r\n\t\t\tit.entity.boundingBox.grow(0.3).rayTrace(currentPos, tracedNextPos).orElse(null)?.let { hit -> EntityRayTraceResult(it.entity, hit) }\r\n\t\t}\r\n\t\t\r\n\t\treturn (entityResult ?: blockResult)?.takeUnless { ForgeEventFactory.onProjectileImpact(this, it) }\r\n\t}\r\n\t\r\n\tprivate fun setExpired(){\r\n\t\tval ownerEntity = owner.get(world)\r\n\t\tval expirePos = posVec.add(cappedMotionVec)\r\n\t\t\r\n\t\tPacketClientFX(FX_EXPIRE, FxExpireData(expirePos, ownerEntity)).let {\r\n\t\t\tit.sendToAllAround(this, 32.0)\r\n\t\t\t\r\n\t\t\tif (ownerEntity is EntityPlayer && expirePos.squareDistanceTo(ownerEntity.posVec) > square(32)){\r\n\t\t\t\tit.sendToPlayer(ownerEntity)\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tremove()\r\n\t}\r\n\t\r\n\toverride fun writeAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\towner.writeToNBT(this, OWNER_TAG)\r\n\t\tputShort(LIFESPAN_TAG, lifespan)\r\n\t\tputFloat(RANGE_TAG, range)\r\n\t}\r\n\t\r\n\toverride fun readAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\towner.readFromNBT(this, OWNER_TAG)\r\n\t\tlifespan = getShort(LIFESPAN_TAG)\r\n\t\trange = getFloat(RANGE_TAG)\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt	(revision 8f737d916101ef6db1e63728ba3f918aa908dc10)
+++ src/main/java/chylex/hee/game/entity/projectile/EntityProjectileSpatialDash.kt	(date 1595089557521)
@@ -181,6 +181,8 @@
 				.sortedBy { it.distanceSqTo(target) }
 				.firstOrNull { canTeleportPlayerOnTop(it, world) }
 			
+			// TODO kinda breaks when teleporting through a window from the inside of a village house
+			
 			if (finalBlock != null){
 				TELEPORT.toBlock(entity, finalBlock.up())
 				return true
Index: src/main/java/chylex/hee/game/entity/item/EntityInfusedTNT.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package chylex.hee.game.entity.item\r\nimport chylex.hee.game.block.info.BlockBuilder.Companion.INDESTRUCTIBLE_HARDNESS\r\nimport chylex.hee.game.item.ItemFlintAndInfernium\r\nimport chylex.hee.game.item.infusion.Infusion.FIRE\r\nimport chylex.hee.game.item.infusion.Infusion.HARMLESS\r\nimport chylex.hee.game.item.infusion.Infusion.MINING\r\nimport chylex.hee.game.item.infusion.Infusion.PHASING\r\nimport chylex.hee.game.item.infusion.Infusion.POWER\r\nimport chylex.hee.game.item.infusion.InfusionList\r\nimport chylex.hee.game.item.infusion.InfusionTag\r\nimport chylex.hee.game.mechanics.explosion.ExplosionBuilder\r\nimport chylex.hee.game.particle.spawner.ParticleSpawnerVanilla\r\nimport chylex.hee.game.particle.util.IShape.Point\r\nimport chylex.hee.init.ModEntities\r\nimport chylex.hee.proxy.Environment\r\nimport chylex.hee.system.migration.vanilla.EntityItem\r\nimport chylex.hee.system.migration.vanilla.EntityLivingBase\r\nimport chylex.hee.system.migration.vanilla.EntityTNTPrimed\r\nimport chylex.hee.system.migration.vanilla.Items\r\nimport chylex.hee.system.util.TagCompound\r\nimport chylex.hee.system.util.allInCenteredSphereMutable\r\nimport chylex.hee.system.util.asVoxelShape\r\nimport chylex.hee.system.util.center\r\nimport chylex.hee.system.util.getMaterial\r\nimport chylex.hee.system.util.getState\r\nimport chylex.hee.system.util.heeTag\r\nimport chylex.hee.system.util.motionY\r\nimport chylex.hee.system.util.nextFloat\r\nimport chylex.hee.system.util.nextItem\r\nimport chylex.hee.system.util.nextRounded\r\nimport chylex.hee.system.util.remapRange\r\nimport chylex.hee.system.util.use\r\nimport net.minecraft.block.BlockState\r\nimport net.minecraft.block.Blocks\r\nimport net.minecraft.block.material.Material\r\nimport net.minecraft.entity.Entity\r\nimport net.minecraft.entity.EntityType\r\nimport net.minecraft.entity.MoverType\r\nimport net.minecraft.entity.MoverType.SELF\r\nimport net.minecraft.inventory.Inventory\r\nimport net.minecraft.item.ItemStack\r\nimport net.minecraft.item.crafting.IRecipeType.SMELTING\r\nimport net.minecraft.network.IPacket\r\nimport net.minecraft.particles.ParticleTypes.SMOKE\r\nimport net.minecraft.util.ReuseableStream\r\nimport net.minecraft.util.math.BlockPos\r\nimport net.minecraft.util.math.Vec3d\r\nimport net.minecraft.util.math.shapes.IBooleanFunction\r\nimport net.minecraft.util.math.shapes.ISelectionContext\r\nimport net.minecraft.util.math.shapes.VoxelShapes\r\nimport net.minecraft.world.Explosion\r\nimport net.minecraft.world.IWorldReader\r\nimport net.minecraft.world.World\r\nimport net.minecraft.world.chunk.ChunkStatus\r\nimport net.minecraft.world.chunk.IChunk\r\nimport net.minecraft.world.server.ServerWorld\r\nimport net.minecraft.world.storage.loot.LootContext\r\nimport net.minecraft.world.storage.loot.LootParameterSets\r\nimport net.minecraft.world.storage.loot.LootParameters\r\nimport net.minecraft.world.storage.loot.LootTables\r\nimport net.minecraftforge.fml.network.NetworkHooks\r\nimport java.util.stream.Stream\r\nimport kotlin.math.PI\r\nimport kotlin.math.cos\r\nimport kotlin.math.sin\r\n\r\nclass EntityInfusedTNT : EntityTNTPrimed{\r\n\tprivate companion object{\r\n\t\tprivate const val WATER_CHECK_RADIUS = 4\r\n\t\tprivate const val PHASING_INSTANT_FUSE_TICKS = 3\r\n\t\t\r\n\t\tprivate const val HAS_INFERNIUM_TAG = \"HasInfernium\"\r\n\t\tprivate const val HAS_PHASED_TAG = \"HasPhased\"\r\n\t\t\r\n\t\tprivate val PARTICLE_TICK = ParticleSpawnerVanilla(SMOKE)\r\n\t\t\r\n\t\t// EntityItem construction\r\n\t\t\r\n\t\tprivate val constructRawItem: (World, Vec3d, ItemStack) -> EntityItem = { world, pos, stack ->\r\n\t\t\tEntityItem(world, pos.x, pos.y, pos.z, stack)\r\n\t\t}\r\n\t\t\r\n\t\tprivate val constructCookedItem: (World, Vec3d, ItemStack) -> EntityItem = { world, pos, stack ->\r\n\t\t\tworld.recipeManager.getRecipe(SMELTING, Inventory(stack), world).orElse(null).let {\r\n\t\t\t\tif (it == null)\r\n\t\t\t\t\tconstructRawItem(world, pos, stack)\r\n\t\t\t\telse\r\n\t\t\t\t\tEntityItemFreshlyCooked(world, pos, it.recipeOutput.copy())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate var igniter: EntityLivingBase? = null\r\n\tprivate var infusions = InfusionList.EMPTY\r\n\tprivate var hasInferniumPower = false\r\n\tprivate var hasPhasedIntoWall = false\r\n\t\r\n\t@Suppress(\"unused\")\r\n\tconstructor(type: EntityType<EntityInfusedTNT>, world: World) : super(type, world)\r\n\t\r\n\tconstructor(world: World, pos: BlockPos, infusions: InfusionList, igniter: EntityLivingBase?, infernium: Boolean) : this(ModEntities.INFUSED_TNT, world){\r\n\t\tsetPosition(pos.x + 0.5, pos.y.toDouble(), pos.z + 0.5)\r\n\t\tprevPosX = posX\r\n\t\tprevPosY = posY\r\n\t\tprevPosZ = posZ\r\n\t\t\r\n\t\tval angle = rand.nextFloat(0.0, 2.0 * PI)\r\n\t\tsetMotion(-sin(angle) * 0.02, 0.2, -cos(angle) * 0.02)\r\n\t\t\r\n\t\tloadInfusions(infusions)\r\n\t\t\r\n\t\tthis.fuse = 80\r\n\t\tthis.igniter = igniter\r\n\t\tthis.hasInferniumPower = infernium\r\n\t}\r\n\t\r\n\tconstructor(world: World, pos: BlockPos, infusions: InfusionList, explosion: Explosion) : this(world, pos, infusions, explosion.explosivePlacedBy, infernium = false){\r\n\t\tthis.fuse = rand.nextInt(fuse / 4) + (fuse / 8)\r\n\t}\r\n\t\r\n\toverride fun createSpawnPacket(): IPacket<*>{\r\n\t\treturn NetworkHooks.getEntitySpawningPacket(this)\r\n\t}\r\n\t\r\n\toverride fun getTntPlacedBy(): EntityLivingBase?{\r\n\t\treturn igniter\r\n\t}\r\n\t\r\n\tprivate fun loadInfusions(infusions: InfusionList){\r\n\t\tthis.infusions = infusions\r\n\t\tthis.noClip = infusions.has(PHASING)\r\n\t}\r\n\t\r\n\toverride fun tick(){\r\n\t\tprevPosX = posX\r\n\t\tprevPosY = posY\r\n\t\tprevPosZ = posZ\r\n\t\t\r\n\t\tif (!hasNoGravity()){\r\n\t\t\tmotionY -= 0.04\r\n\t\t}\r\n\t\t\r\n\t\tmove(SELF, motion)\r\n\t\tmotion = motion.scale(0.98)\r\n\t\t\r\n\t\tif (onGround){\r\n\t\t\tmotion = motion.mul(0.7, -0.5, 0.7)\r\n\t\t}\r\n\t\t\r\n\t\tif (--fuse <= 0){\r\n\t\t\tremove()\r\n\t\t\tblowUp()\r\n\t\t}\r\n\t\telse{\r\n\t\t\thandleWaterMovement()\r\n\t\t\tPARTICLE_TICK.spawn(Point(posX, posY + 0.5, posZ, 1), rand)\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Phasing\r\n\t\r\n\toverride fun move(type: MoverType, by: Vec3d){\r\n\t\tval wasNoclip = noClip\r\n\t\t\r\n\t\tnoClip = false\r\n\t\tsuper.move(type, by)\r\n\t\tnoClip = wasNoclip\r\n\t\t\r\n\t\tif (noClip && type == SELF){\r\n\t\t\tif (!world.hasNoCollisions(boundingBox)){\r\n\t\t\t\thasPhasedIntoWall = true\r\n\t\t\t}\r\n\t\t\telse if (hasPhasedIntoWall && fuse > PHASING_INSTANT_FUSE_TICKS){\r\n\t\t\t\tfuse = PHASING_INSTANT_FUSE_TICKS\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\toverride fun getAllowedMovement(motion: Vec3d): Vec3d{\r\n\t\tif (infusions.has(PHASING)){\r\n\t\t\tif (motion.lengthSquared() == 0.0){\r\n\t\t\t\treturn motion\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tval aabb = boundingBox\r\n\t\t\tval context = ISelectionContext.forEntity(this)\r\n\t\t\t\r\n\t\t\tval borderShape = world.worldBorder.shape\r\n\t\t\tval borderStream = if (VoxelShapes.compare(borderShape, aabb.shrink(1.0E-7).asVoxelShape, IBooleanFunction.AND))\r\n\t\t\t\tStream.empty()\r\n\t\t\telse\r\n\t\t\t\tStream.of(borderShape)\r\n\t\t\t\r\n\t\t\tval shapeStream = world.getEmptyCollisionShapes(this, aabb.expand(motion), emptySet())\r\n\t\t\tval stream = ReuseableStream(Stream.concat(shapeStream, borderStream))\r\n\t\t\t\r\n\t\t\tval indestructibleOnlyWorld = object : IWorldReader by world{\r\n\t\t\t\tprivate fun returnOnlyIndestructible(state: BlockState, pos: BlockPos): BlockState{\r\n\t\t\t\t\treturn if (state.getBlockHardness(world, pos) == INDESTRUCTIBLE_HARDNESS)\r\n\t\t\t\t\t\tstate\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tBlocks.AIR.defaultState\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\toverride fun getBlockState(pos: BlockPos): BlockState{\r\n\t\t\t\t\treturn returnOnlyIndestructible(pos.getState(world), pos)\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\toverride fun getChunk(x: Int, z: Int, requiredStatus: ChunkStatus, nonNull: Boolean): IChunk?{\r\n\t\t\t\t\tval chunk = world.getChunk(x, z, requiredStatus, nonNull) ?: return null\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn object : IChunk by chunk{\r\n\t\t\t\t\t\toverride fun getBlockState(pos: BlockPos): BlockState{\r\n\t\t\t\t\t\t\treturn returnOnlyIndestructible(chunk.getBlockState(pos), pos)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tval movingX = motion.x == 0.0\r\n\t\t\tval movingY = motion.y == 0.0\r\n\t\t\tval movingZ = motion.z == 0.0\r\n\t\t\t\r\n\t\t\treturn if ((!movingX || !movingY) && (!movingX || !movingZ) && (!movingY || !movingZ))\r\n\t\t\t\tEntity.collideBoundingBox(motion, aabb, ReuseableStream(Stream.concat(stream.createStream(), indestructibleOnlyWorld.getCollisionShapes(this, aabb.expand(motion)))))\r\n\t\t\telse\r\n\t\t\t\tEntity.getAllowedMovement(motion, aabb, indestructibleOnlyWorld, context, stream)\r\n\t\t}\r\n\t\t\r\n\t\treturn super.getAllowedMovement(motion)\r\n\t}\r\n\t\r\n\t// Explosion handling\r\n\t\r\n\tprivate fun blowUp(){\r\n\t\tif (world.isRemote){\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\r\n\t\tval strength = (if (infusions.has(POWER)) 6F else 4F) * (if (hasInferniumPower) ItemFlintAndInfernium.EXPLOSION_MULTIPLIER else 1F)\r\n\t\t\r\n\t\tval isFiery = infusions.has(FIRE)\r\n\t\tval isHarmless = infusions.has(HARMLESS)\r\n\t\tval isMining = infusions.has(MINING)\r\n\t\t\r\n\t\tval dropRateMultiplier: Float\r\n\t\tval dropFortune: Int\r\n\t\t\r\n\t\tif (isMining){\r\n\t\t\tdropRateMultiplier = 3F\r\n\t\t\tdropFortune = 1\r\n\t\t}\r\n\t\telse{\r\n\t\t\tdropRateMultiplier = 1F\r\n\t\t\tdropFortune = 0\r\n\t\t}\r\n\t\t\r\n\t\twith(ExplosionBuilder()){\r\n\t\t\tthis.destroyBlocks = !isHarmless\r\n\t\t\tthis.damageEntities = !isHarmless\r\n\t\t\t\r\n\t\t\tthis.spawnFire = isFiery\r\n\t\t\tthis.blockDropRateMultiplier = dropRateMultiplier\r\n\t\t\tthis.blockDropFortune = dropFortune\r\n\t\t\t\r\n\t\t\ttrigger(world, this@EntityInfusedTNT, posX, posY + (height / 16.0), posZ, strength)\r\n\t\t}\r\n\t\t\r\n\t\tif (isMining && isInWater){\r\n\t\t\tperformFishing(isFiery)\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate fun performFishing(cook: Boolean){\r\n\t\tvar totalCountedBlocks = 0\r\n\t\tval foundWaterBlocks = mutableListOf<BlockPos>()\r\n\t\t\r\n\t\tfor(pos in position.allInCenteredSphereMutable(WATER_CHECK_RADIUS)){\r\n\t\t\t++totalCountedBlocks\r\n\t\t\t\r\n\t\t\tif (pos.getMaterial(world) === Material.WATER){\r\n\t\t\t\tfoundWaterBlocks.add(pos.toImmutable())\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (foundWaterBlocks.isNotEmpty()){\r\n\t\t\tval waterRatio = foundWaterBlocks.size.toFloat() / totalCountedBlocks\r\n\t\t\t\r\n\t\t\tval dropAmount = when{\r\n\t\t\t\twaterRatio < 0.1 -> remapRange(waterRatio, (0.0F)..(0.1F), (1.0F)..(1.6F))\r\n\t\t\t\twaterRatio < 0.4 -> remapRange(waterRatio, (0.1F)..(0.4F), (1.6F)..(4.0F))\r\n\t\t\t\telse             -> remapRange(waterRatio, (0.4F)..(1.0F), (4.0F)..(5.8F))\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tval lootTable = Environment.getLootTable(LootTables.GAMEPLAY_FISHING)\r\n\t\t\tval lootContext = LootContext.Builder(world as ServerWorld)\r\n\t\t\t\t.withRandom(rand)\r\n\t\t\t\t.withParameter(LootParameters.POSITION, position)\r\n\t\t\t\t.withParameter(LootParameters.TOOL, ItemStack(Items.FISHING_ROD))\r\n\t\t\t\t.build(LootParameterSets.FISHING)\r\n\t\t\t\r\n\t\t\tval constructItemEntity = if (cook) constructCookedItem else constructRawItem\r\n\t\t\t\r\n\t\t\trepeat(rand.nextRounded(dropAmount)){\r\n\t\t\t\tfor(droppedItem in lootTable.generate(lootContext)){ // there's ItemFishedEvent but it needs the hook entity...\r\n\t\t\t\t\tval dropPos = rand.nextItem(foundWaterBlocks).center.add(\r\n\t\t\t\t\t\trand.nextFloat(-0.25, 0.25),\r\n\t\t\t\t\t\trand.nextFloat(-0.25, 0.25),\r\n\t\t\t\t\t\trand.nextFloat(-0.25, 0.25)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t\r\n\t\t\t\t\tconstructItemEntity(world, dropPos, droppedItem).apply {\r\n\t\t\t\t\t\tmotion = Vec3d(\r\n\t\t\t\t\t\t\trand.nextFloat(-0.25, 0.25),\r\n\t\t\t\t\t\t\trand.nextFloat(1.0, 1.2),\r\n\t\t\t\t\t\t\trand.nextFloat(-0.25, 0.25)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tworld.addEntity(this)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Serialization\r\n\t\r\n\toverride fun writeAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\tsuper.writeAdditional(nbt)\r\n\t\t\r\n\t\tInfusionTag.setList(this, infusions)\r\n\t\tputBoolean(HAS_INFERNIUM_TAG, hasInferniumPower)\r\n\t\tputBoolean(HAS_PHASED_TAG, hasPhasedIntoWall)\r\n\t}\r\n\t\r\n\toverride fun readAdditional(nbt: TagCompound) = nbt.heeTag.use {\r\n\t\tsuper.readAdditional(nbt)\r\n\t\t\r\n\t\tloadInfusions(InfusionTag.getList(this))\r\n\t\thasInferniumPower = getBoolean(HAS_INFERNIUM_TAG)\r\n\t\thasPhasedIntoWall = getBoolean(HAS_PHASED_TAG)\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/chylex/hee/game/entity/item/EntityInfusedTNT.kt	(revision 8f737d916101ef6db1e63728ba3f918aa908dc10)
+++ src/main/java/chylex/hee/game/entity/item/EntityInfusedTNT.kt	(date 1595089557516)
@@ -312,7 +312,7 @@
 					constructItemEntity(world, dropPos, droppedItem).apply {
 						motion = Vec3d(
 							rand.nextFloat(-0.25, 0.25),
-							rand.nextFloat(1.0, 1.2),
+							rand.nextFloat(1.0, 1.2), // TODO power?
 							rand.nextFloat(-0.25, 0.25)
 						)
 						
